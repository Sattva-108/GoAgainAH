local addonName, ns = ...
local L = ns.L

local Addon = LibStub("AceAddon-3.0"):NewAddon("AuctionHouse", "AceComm-3.0", "AceSerializer-3.0")
ns.AuctionHouseAddon = Addon
local LibDeflate = LibStub("LibDeflate")
local API = ns.AuctionHouseAPI

ns.MobNameByID = {}
ns.MobIDByName = {}

-- Paste the sorted uniqueMobNamesCause7 list from above here:
local uniqueMobNamesCause7 = {
    "XT", -- [1]
    "«Мокрый» Пит", -- [2]
    "Адепт клана Пылающего Клинка", -- [3]
    "Адепт предатель", -- [4]
    "Аззира Клинок Небес", -- [5]
    "Аккрилус", -- [6]
    "Аксариенский плут", -- [7]
    "Аксариенский призыватель огня", -- [8]
    "Альдарон Безрассудный", -- [9]
    "Аманийский берсерк", -- [10]
    "Анок'сутен", -- [11]
    "Ануб'арский гнилостный зверь", -- [12]
    "Ануб'арский душитель", -- [13]
    "Аптекарь Йорель", -- [14]
    "Араззиус Безжалостный", -- [15]
    "Арра'чея", -- [16]
    "Астральный пожиратель", -- [17]
    "Баг'тира", -- [18]
    "Багровый слизнюк", -- [19]
    "Бализар Скверный", -- [20]
    "Бандит", -- [21]
    "Бандит из стаи Речной Лапы", -- [22]
    "Бантар", -- [23]
    "Барон Акванис", -- [24]
    "Барон Дольноберег", -- [25]
    "Батрак Торговой Компании", -- [26]
    "Батрак из клана Кровавой Глазницы", -- [27]
    "Беговой олень-рогач", -- [28]
    "Бегун топей из стаи Мохошкуров", -- [29]
    "Бездушный вурдалак", -- [30]
    "Безумный дикий совух", -- [31]
    "Безумный дракондор", -- [32]
    "Бейл'Гор", -- [33]
    "Бейл'данский землечерп", -- [34]
    "Бейл'данский офицер", -- [35]
    "Бейл'данский ружейник", -- [36]
    "Бейл'данский старшина", -- [37]
    "Белоголов Лунной Ярости", -- [38]
    "Берсерк Амани", -- [39]
    "Бес-прислужник", -- [40]
    "Бесселет", -- [41]
    "Бесцветный ворг", -- [42]
    "Бешенер из племени Иглогривых", -- [43]
    "Бешенка", -- [44]
    "Бешеный ворг", -- [45]
    "Бешеный гнолл из стаи Темношкуров", -- [46]
    "Бешеный длиннозуб", -- [47]
    "Бешеный колючешерстный медведь", -- [48]
    "Бичевательница Маннорока", -- [49]
    "Блеклоперый крылень", -- [50]
    "Блестопанцирный крепкохват", -- [51]
    "Боевая пантера Курцена", -- [52]
    "Боевая пантера Устана", -- [53]
    "Боевой разоритель", -- [54]
    "Боевой страж племени Иглогривых", -- [55]
    "Боевой страж племени Иглошкурых", -- [56]
    "Боевой тигр Курцена", -- [57]
    "Болотный бегун из клана Драконьей Пасти", -- [58]
    "Болотный кроколиск", -- [59]
    "Болотный ягуар", -- [60]
    "Больной беженец", -- [61]
    "Больной черный медведь", -- [62]
    "Большая сумеречница", -- [63]
    "Большой Буоно", -- [64]
    "Большой грозовой змей", -- [65]
    "Большой лабиринтовый нетопырь", -- [66]
    "Большой паук-прядильщик", -- [67]
    "Большой равнинный долгоног", -- [68]
    "Борец Устана", -- [69]
    "Браконьер из стаи Красногорья", -- [70]
    "Брат Вороний Дуб", -- [71]
    "Бригадир Зубовиззл", -- [72]
    "Бригадир Торговой Компании", -- [73]
    "Бригадир Шумовик", -- [74]
    "Бродяжница из стаи Кровавой Ярости", -- [75]
    "Бузотер Торговой Компании", -- [76]
    "Буревестница из племени Колкар", -- [77]
    "Бурешкура", -- [78]
    "Буян", -- [79]
    "Буян из племени Каменного Свода", -- [80]
    "Быстрогрив", -- [81]
    "Вагаш", -- [82]
    "Валдред Морай", -- [83]
    "Ваште Пауни", -- [84]
    "Ведмедь из племени Гиблой Чащи", -- [85]
    "Ведьма гроз из стаи Кровавой Ярости", -- [86]
    "Ведьмак племени Призрачной Сосны", -- [87]
    "Величавая виверна", -- [88]
    "Величавый небесный охотник", -- [89]
    "Верог Дервиш", -- [90]
    "Верховный вождь племени Косолапов", -- [91]
    "Верховный генерал Аббендис", -- [92]
    "Верховный жрец Зушол", -- [93]
    "Вестник Тьмы Лунной Ярости", -- [94]
    "Вестник Тьмы из стаи Ночной Погибели", -- [95]
    "Вестник Ужаса", -- [96]
    "Вестник из клана Черной горы", -- [97]
    "Вестница Ясеневого леса", -- [98]
    "Ветроплет из Братства Справедливости", -- [99]
    "Ветрух-матриарх", -- [100]
    "Взбешенный дух камня", -- [101]
    "Взрослый лунопард", -- [102]
    "Взрослый прыголап", -- [103]
    "Взрыв-бот", -- [104]
    "Взрывоопасная овца", -- [105]
    "Виверна Скального гнездовья", -- [106]
    "Визгливая гарпия", -- [107]
    "Вит Карлеон", -- [108]
    "Вихревой штормоход", -- [109]
    "Владыка теней Скверн'дан", -- [110]
    "Властитель Дракуру", -- [111]
    "Водоискатель из племени Дыбогривов", -- [112]
    "Водоискатель из племени Иглогривых", -- [113]
    "Водянистый захватчик", -- [114]
    "Военный инструктор Зурок", -- [115]
    "Вожак стаи Красногорья", -- [116]
    "Вожак стаи Хумар", -- [117]
    "Вождь Зул'Марош", -- [118]
    "Вождь Умуру", -- [119]
    "Воин Алого ордена", -- [120]
    "Воин Туманного Сердца", -- [121]
    "Воин из клана Скользящего Плавника", -- [122]
    "Воин из племени Косолапов", -- [123]
    "Воин из племени Черного Ила", -- [124]
    "Воин из племени Чернолесья", -- [125]
    "Воин из стаи Темношкуров", -- [126]
    "Воин племени Гласа Дождя", -- [127]
    "Воин племени Серой Мглы", -- [128]
    "Воитель из клана Черной горы", -- [129]
    "Волдырный гнилостень", -- [130]
    "Волк племени Иглогривых", -- [131]
    "Волнолов из племени Злобного Плавника", -- [132]
    "Волнолов маны", -- [133]
    "Волномут из племени Злобного Плавника", -- [134]
    "Волтрис", -- [135]
    "Волчий ужас", -- [136]
    "Волчонок Порочной Ветви", -- [137]
    "Волшебник Синдиката", -- [138]
    "Волшебник Янтарной мельницы", -- [139]
    "Волшебный обнулятор X-21", -- [140]
    "Волшебный разоритель", -- [141]
    "Вор Синдиката", -- [142]
    "Ворг", -- [143]
    "Ворг-волкостраж", -- [144]
    "Ворген Кровавой Луны", -- [145]
    "Ворген из стаи Ночной Погибели", -- [146]
    "Ворожей из племени Порочной Ветви", -- [147]
    "Воронковый паук Ядовитого Тумана", -- [148]
    "Воронковый паук дикого терна", -- [149]
    "Воронковый паук-прядильщик", -- [150]
    "Восставший дух", -- [151]
    "Восставший егерь крепости", -- [152]
    "Восставший кавалер", -- [153]
    "Восставший ловчий", -- [154]
    "Восставший ненасытник", -- [155]
    "Восставший чароплет", -- [156]
    "Врагорез-4000", -- [157]
    "Вредитель-туннельщик", -- [158]
    "Всепожирающая эктоплазма", -- [159]
    "Вурдалак-живодер", -- [160]
    "Вызыватель из Братства Справедливости", -- [161]
    "Вызыватель из клана Костеглодов", -- [162]
    "Высокогрив саванны", -- [163]
    "Высохший хранитель лесов", -- [164]
    "Газз'уз", -- [165]
    "Галганн Огнемолот", -- [166]
    "Гарпия из стаи Зачарованного Крыла", -- [167]
    "Гарпия из стаи Кровавой Ярости", -- [168]
    "Гарр Просоленное Копыто", -- [169]
    "Гат'Илзогг", -- [170]
    "Гвардеец Курцена", -- [171]
    "Гелтарис", -- [172]
    "Генерал Двукосса", -- [173]
    "Геодезист-туннельщик", -- [174]
    "Геолог Торговой Компании", -- [175]
    "Геомант из племени Дыбогривов", -- [176]
    "Геомант из племени Золотого Песка", -- [177]
    "Геомант из племени Камнедробов", -- [178]
    "Геомант из племени Камнепадов", -- [179]
    "Геомант племени Зловещего Тотема", -- [180]
    "Геомант племени Иглогривых", -- [181]
    "Геомант-туннельщик", -- [182]
    "Геренцо Терминатрикс", -- [183]
    "Гешарахан", -- [184]
    "Гибломор", -- [185]
    "Гигантский бешеный медведь", -- [186]
    "Гигантский равнинный ползун", -- [187]
    "Гиена племени Колкар", -- [188]
    "Главный инженер Горк'лонн", -- [189]
    "Гладиатор из клана Черной горы", -- [190]
    "Гленн Станфорд", -- [191]
    "Гневный гнолл из стаи Гнилошкуров", -- [192]
    "Гневный колосс", -- [193]
    "Гневный лунный совух", -- [194]
    "Гневный рифовый краб", -- [195]
    "Гнилая нежить", -- [196]
    "Гнилокост-колдун", -- [197]
    "Гнилокровный тролль", -- [198]
    "Гнилорыг", -- [199]
    "Гнилостный медведь", -- [200]
    "Гнилоступ", -- [201]
    "Гниющий предок", -- [202]
    "Гниющий ужас", -- [203]
    "Гнолл из стаи Мохошкуров", -- [204]
    "Гнолл из стаи Темношкуров", -- [205]
    "Гнолл-чернолап", -- [206]
    "Гнусный грелль", -- [207]
    "Гоблин-корабел", -- [208]
    "Головолом из племени Каменной Челюсти", -- [209]
    "Головолом из племени Камнедробов", -- [210]
    "Головорез Синдиката", -- [211]
    "Головорез Торговой Компании", -- [212]
    "Головорез из клана Пламенеющего Клинка", -- [213]
    "Головорез из клана Раздробленного Хребта", -- [214]
    "Голодающий тролль Плети", -- [215]
    "Голодный горный лев", -- [216]
    "Голодный лютый волк", -- [217]
    "Голодный хромоног", -- [218]
    "Гонец из стаи Речной Лапы", -- [219]
    "Гончий пес", -- [220]
    "Гор'марок Опустошитель", -- [221]
    "Горлаш", -- [222]
    "Горнорабочий из Братства Справедливости", -- [223]
    "Горный лев", -- [224]
    "Горный пехотинец Дун Гарока", -- [225]
    "Госпожа Судьбы", -- [226]
    "Грабитель Южных морей", -- [227]
    "Графф Быстрохват", -- [228]
    "Гроддокский рокотун", -- [229]
    "Грозный страж", -- [230]
    "Грозовая ведьма из стаи Пыльного Ветра", -- [231]
    "Грозорыл", -- [232]
    "Громаг", -- [233]
    "Громила из клана Мо'Грош", -- [234]
    "Громила из клана Мош'Огг", -- [235]
    "Громила из клана Песчаного Молота", -- [236]
    "Громила из племени Зловещего Тотема", -- [237]
    "Громила из стаи Гнилошкуров", -- [238]
    "Громила из стаи Красногорья", -- [239]
    "Громила из стаи Речной Лапы", -- [240]
    "Громила из стаи Темношкуров", -- [241]
    "Громоголовый гиппогриф", -- [242]
    "Грохотунья", -- [243]
    "Грохочущий изгнанник", -- [244]
    "Грубобрюх", -- [245]
    "Грязекоп из племени Болотного Плавника", -- [246]
    "Грязекоп из племени Синежабрых", -- [247]
    "Грязекуп-крепкохват", -- [248]
    "Грязекуп-острозуб", -- [249]
    "Грязнопанцирный клешнекоп", -- [250]
    "Губитель из стаи Красногорья", -- [251]
    "Гьялербронский скелет", -- [252]
    "Дагун Ненасытный", -- [253]
    "Дал Жилотяг", -- [254]
    "Даларанский призыватель", -- [255]
    "Даларанский стражник со щитом", -- [256]
    "Даларанский ученик", -- [257]
    "Даларанский чудотворец", -- [258]
    "Дар'Кхан Дратир", -- [259]
    "Дарнасская охотница", -- [260]
    "Дворф из клана Черного Железа", -- [261]
    "Дева Пустоты", -- [262]
    "Дедушка Вишас", -- [263]
    "Демон Бездны", -- [264]
    "Детеныш крабстера", -- [265]
    "Детеныш черного дракона", -- [266]
    "Детеныш черной вдовы", -- [267]
    "Джеденарский адепт", -- [268]
    "Джеденарский сектант", -- [269]
    "Джеденарский страж", -- [270]
    "Джеденарский темноплет", -- [271]
    "Джон-Джон Ворон", -- [272]
    "Джурион Обманщик", -- [273]
    "Диатор Ищейка", -- [274]
    "Диб", -- [275]
    "Диверсант Курцена", -- [276]
    "Дикарка из стаи Пыльного Ветра", -- [277]
    "Дикарь Когтистой Лапы", -- [278]
    "Дикарь из стаи Гнилошкуров", -- [279]
    "Дикий ворген", -- [280]
    "Дикий змей", -- [281]
    "Длань Когтя Ворона", -- [282]
    "Добытчик из племени Черного Ила", -- [283]
    "Добытчик-туннельщик", -- [284]
    "Дозорный из племени Зимней Спячки", -- [285]
    "Дозорный полей", -- [286]
    "Долгоног нагорья", -- [287]
    "Драконид Хладарры", -- [288]
    "Древний голем", -- [289]
    "Дриада Мутного озера", -- [290]
    "Дробитель", -- [291]
    "Друг \"Проныры\"", -- [292]
    "Друид-змея", -- [293]
    "Дух волка племени Зловещего Тотема", -- [294]
    "Дух древности", -- [295]
    "Дух мертвоброда из племени Атал'ай", -- [296]
    "Душегуб Скверны", -- [297]
    "Душегуб из стаи Темношкуров", -- [298]
    "Душегубка из стаи Зачарованного Крыла", -- [299]
    "Душегубка из стаи Кровавой Ярости", -- [300]
    "Душитель из пещерных глубин", -- [301]
    "Душитель из племени Зимней Спячки", -- [302]
    "Душительница из стаи Кровавой Ярости", -- [303]
    "Жевра-бегун", -- [304]
    "Жевра-скакун", -- [305]
    "Железнорукий страж", -- [306]
    "Железноспин", -- [307]
    "Железный точильщик рун", -- [308]
    "Живой жар", -- [309]
    "Живорез из племени Злобного Плавника", -- [310]
    "Жрица прилива из Непроглядной Пучины", -- [311]
    "Жутекостный скелет", -- [312]
    "Жутекостный скелет-часовой", -- [313]
    "Жуткий перепелятник", -- [314]
    "Заблудший искатель разрыва", -- [315]
    "Забраксис", -- [316]
    "Загадочный аспид", -- [317]
    "Загадочный душегуб", -- [318]
    "Загадочный жалохлест", -- [319]
    "Загадочный крылозмей", -- [320]
    "Загадочный крылояд", -- [321]
    "Загадочный ловец", -- [322]
    "Загадочный опустошитель", -- [323]
    "Загадочный плеточник", -- [324]
    "Загадочный шаркун", -- [325]
    "Загадочный ящер", -- [326]
    "Загрязненная капля", -- [327]
    "Заклинатель духа волка племени Зловещего Тотема", -- [328]
    "Заклинатель рун из клана Укротителей драконов", -- [329]
    "Заключенный из Братства Справедливости", -- [330]
    "Заколдованный Хобгоблин", -- [331]
    "Замученный горожанин", -- [332]
    "Заразная крыса", -- [333]
    "Зарослевый хищник", -- [334]
    "Заступник Янтарной мельницы", -- [335]
    "Заступник-силитид", -- [336]
    "Захватчик из пещерных глубин", -- [337]
    "Захватчик из племени Колкар", -- [338]
    "Зачарованный фолиант", -- [339]
    "Защитник из Алого ордена", -- [340]
    "Защитник из племени Кривой Сосны", -- [341]
    "Защитник племени Иглогривых", -- [342]
    "Зверолов Амани", -- [343]
    "Зверолов из Братства Справедливости", -- [344]
    "Зверолов из стаи Древолапов", -- [345]
    "Зелемар Гневный", -- [346]
    "Зеленый паук-отшельник", -- [347]
    "Землеглот из пещерных глубин", -- [348]
    "Землекоп Огнеплав", -- [349]
    "Землекоп из Братства Справедливости", -- [350]
    "Землекоп из племени Ветрорезов", -- [351]
    "Землекоп из племени Камнедробов", -- [352]
    "Землекоп-туннельщик", -- [353]
    "Землемер из клана Солнечного Ястреба", -- [354]
    "Землепроходец из племени Иглогривых", -- [355]
    "Землепроходец из племени Колючего Меха", -- [356]
    "Землепроходец из племени Чернолесья", -- [357]
    "Злобный ночной кругопряд", -- [358]
    "Злобный равнинный долгоног", -- [359]
    "Злобный серый медведь", -- [360]
    "Злобный элементаль воды", -- [361]
    "Зловепрь", -- [362]
    "Зловонный труп", -- [363]
    "Злоумышленник из племени Дыбогривов", -- [364]
    "Змеестраж из клана Бича Злобы", -- [365]
    "Змеестраж из клана Гребня Ненависти", -- [366]
    "Змей Янтарной мельницы", -- [367]
    "Знахарь Курцена", -- [368]
    "Знахарь из клана Песчаной Бури", -- [369]
    "Знахарь из племени Порочной Ветви", -- [370]
    "Знахарь из племени Сухокожих", -- [371]
    "Зовущая Бездну из клана Темной Нити", -- [372]
    "Зомби Занзила", -- [373]
    "Зомби из племени Темной Чешуи", -- [374]
    "Зубастая гиена", -- [375]
    "Зул'фарракский зомби", -- [376]
    "Зулфи Ун'тула", -- [377]
    "Ивар Нечистый", -- [378]
    "Изверг Острого Клыка", -- [379]
    "Изверг из клана Мош'Огг", -- [380]
    "Изверг из клана Раздробленного Хребта", -- [381]
    "Изгнанная некромантка", -- [382]
    "Изможденный беженец", -- [383]
    "Изумрудон-оракул", -- [384]
    "Иллидарский солдат", -- [385]
    "Иллюзорный волк", -- [386]
    "Иллюзорный призрак", -- [387]
    "Иллюзорный фантазм", -- [388]
    "Императорский элементалист", -- [389]
    "Инженер Безобразец", -- [390]
    "Ирреальный искатель", -- [391]
    "Ирреальный наблюдатель", -- [392]
    "Искатель реликвий Торговой Компании", -- [393]
    "Иссохший мурлок из племени Зловещей Чешуи", -- [394]
    "Истязатель из Алого ордена", -- [395]
    "Исчадие тьмы", -- [396]
    "Исчадие эфира", -- [397]
    "Ит'рикс Жнец", -- [398]
    "Ичияки", -- [399]
    "Ищейка Каменного Крыла", -- [400]
    "Ищейка из Алого ордена", -- [401]
    "Ищейка из Братства Справедливости", -- [402]
    "Каарж Бесформенный", -- [403]
    "Кабан из свиты", -- [404]
    "Кавалер Алого ордена Дарген", -- [405]
    "Каверзный грелль Скверны", -- [406]
    "Каз", -- [407]
    "Кал'дорайский дух", -- [408]
    "Каменное Копье", -- [409]
    "Каменный великан", -- [410]
    "Камнезобый василиск", -- [411]
    "Камнекрыл-душегуб", -- [412]
    "Камнерез из племени Ветрорезов", -- [413]
    "Канонир Вессан", -- [414]
    "Канонир Южных морей", -- [415]
    "Канюк-костеклювач", -- [416]
    "Капеллан Алого ордена", -- [417]
    "Капитан Вакон", -- [418]
    "Капитан Гордостанная", -- [419]
    "Капитан Зеленямс", -- [420]
    "Капитан Кильватель", -- [421]
    "Капитан Мелраш", -- [422]
    "Капитан Штиллец", -- [423]
    "Капитан-костещеп", -- [424]
    "Караванщик Тсет", -- [425]
    "Караульный Алого ордена", -- [426]
    "Караульный Синдиката", -- [427]
    "Караульный дозорного укрепления", -- [428]
    "Караульный из клана Черной горы", -- [429]
    "Карманник", -- [430]
    "Кастетник из Братства Справедливости", -- [431]
    "Каторжник", -- [432]
    "Кел'гаш Коварный", -- [433]
    "Келейник Алого ордена", -- [434]
    "Кель'дорайское привидение", -- [435]
    "Кенарийский ботаник", -- [436]
    "Кенарийский воздаятель", -- [437]
    "Кенарийский друид", -- [438]
    "Кентавр из племени Колкар", -- [439]
    "Кипящий дух", -- [440]
    "Кипящий элементаль", -- [441]
    "Кишкодер", -- [442]
    "Клерк Гораций Белоконь", -- [443]
    "Клонированная эктоплазма", -- [444]
    "Кнутохлест", -- [445]
    "Кобольд-туннельщик", -- [446]
    "Кобольд-шахтер", -- [447]
    "Коварная жрица Ведьмиса", -- [448]
    "Коварное Жало", -- [449]
    "Коварный грелль", -- [450]
    "Койот", -- [451]
    "Колдун Янтарной мельницы", -- [452]
    "Колдун племени Зловещего Тотема", -- [453]
    "Колдунья Пустоты", -- [454]
    "Колдунья из клана Гребня Ненависти", -- [455]
    "Колдунья из клана Гремучей Чешуи", -- [456]
    "Колючешерстный медведь", -- [457]
    "Компактный уборочный голем", -- [458]
    "Контрабандист из Братства Справедливости", -- [459]
    "Король Бангалаш", -- [460]
    "Король Мош", -- [461]
    "Костегрыз из племени Золотого Песка", -- [462]
    "Костегрыз из племени Каменной Челюсти", -- [463]
    "Костегрыз из племени Камнедробов", -- [464]
    "Костелапая гиена", -- [465]
    "Костестраж из клана Драконьей Пасти", -- [466]
    "Костолом из клана Пылающего Клинка", -- [467]
    "Краб с мертвой хваткой", -- [468]
    "Крадущийся йети со Свирепого Утеса", -- [469]
    "Крапчатый крикун", -- [470]
    "Крапчатый острозуб", -- [471]
    "Крапчатый смертехват", -- [472]
    "Крапчатый ящер", -- [473]
    "Красная драконида", -- [474]
    "Крепкозуб Темных берегов", -- [475]
    "Крикунья из клана Зловещей Чешуи", -- [476]
    "Криниг Грознорыл", -- [477]
    "Кристаллиновый древень", -- [478]
    "Кристаллиновый ползун", -- [479]
    "Кровавый Пир", -- [480]
    "Кровавый ревун Лунной Ярости", -- [481]
    "Кровоклык", -- [482]
    "Кровопалый лезвезуб", -- [483]
    "Кровопийца из племени Песчаной Бури", -- [484]
    "Кровопыт из племени Колкар", -- [485]
    "Кровоточащий ужас", -- [486]
    "Кроколиск-хрустогрыз", -- [487]
    "Крупнозубый кроколиск", -- [488]
    "Крупный горный лев", -- [489]
    "Крупный тарантул", -- [490]
    "Крушитель из племени Зловещего Тотема", -- [491]
    "Крылатый стражник Скеттиса", -- [492]
    "Крыло скорби", -- [493]
    "Кудесник из Братства Справедливости", -- [494]
    "Курьер из Багрового Легиона", -- [495]
    "Кусачий краб", -- [496]
    "Кусеница", -- [497]
    "Куссан Жалящий", -- [498]
    "Лабиринтовый нетопырь", -- [499]
    "Ледион", -- [500]
    "Ледоглазый василиск", -- [501]
    "Ледоскал", -- [502]
    "Лейтенант Храброглас", -- [503]
    "Лекарь Темной Крови", -- [504]
    "Лепрогном", -- [505]
    "Лесной паук-скрытень", -- [506]
    "Лесной хищник", -- [507]
    "Лесозаготовитель Торговой Компании", -- [508]
    "Лесоруб Торговой Компании", -- [509]
    "Лихоимец из Братства Справедливости", -- [510]
    "Личинка силитида", -- [511]
    "Ловчий из Садов Лунного Покоя", -- [512]
    "Ловчий из клана Гэрдан", -- [513]
    "Ловчий из племени Иглогривых", -- [514]
    "Ловчий смерти", -- [515]
    "Локен", -- [516]
    "Лорд Малатром", -- [517]
    "Лорд Меленас", -- [518]
    "Лорд-мэр Моррисон", -- [519]
    "Луговой бегун из стаи Гнилошкуров", -- [520]
    "Лузран", -- [521]
    "Лунный совух", -- [522]
    "Лунопард", -- [523]
    "Лунопард-матриарх", -- [524]
    "Лютый седой медведь", -- [525]
    "Ма'рук Змеиная Чешуя", -- [526]
    "Маг из шайки Кровавого Паруса", -- [527]
    "Маг-скелет", -- [528]
    "Магистр Янтарной мельницы", -- [529]
    "Магмус", -- [530]
    "Магош", -- [531]
    "Май'Зот", -- [532]
    "Малатром оскверненный", -- [533]
    "Малорослый лунопард", -- [534]
    "Мана-змей", -- [535]
    "Марзон Бесшумный Клинок", -- [536]
    "Мародер из клана Пронзающего Гребня", -- [537]
    "Мародер из племени Галак", -- [538]
    "Мародер из племени Колкар", -- [539]
    "Масофет Черный", -- [540]
    "Мастер клинка из клана Гэрдан", -- [541]
    "Мастер проклятий из племени Призрачной Сосны", -- [542]
    "Матис Жестокий", -- [543]
    "Матриарх саванны", -- [544]
    "Матриарх стаи Неистовства Ветра", -- [545]
    "Матрос из шайки Кровавого Паруса", -- [546]
    "Мать-медведица", -- [547]
    "Машиностроитель Торговой Компании", -- [548]
    "Медведь Ясеневого леса", -- [549]
    "Медведь-ледолап", -- [550]
    "Медведь-щербозуб", -- [551]
    "Мертвая почва", -- [552]
    "Мертвяк из Братства Справедливости", -- [553]
    "Метатель топоров из племени Амани", -- [554]
    "Метатель топоров из племени Порочной Ветви", -- [555]
    "Метатель топоров из племени Сухокожих", -- [556]
    "Метатель топоров из племени Тлеющего Терновника", -- [557]
    "Механик Торговой Компании", -- [558]
    "Механический караульный", -- [559]
    "Механический страж", -- [560]
    "Мизраэль", -- [561]
    "Милтон Шлепс", -- [562]
    "Мирмидон из клана Гребня Ненависти", -- [563]
    "Мирмидон из клана Скользящего Плавника", -- [564]
    "Мирмидон предатель", -- [565]
    "Мировой судья Бернсайд", -- [566]
    "Миротворец Шаттрата", -- [567]
    "Мистик Острого Клыка", -- [568]
    "Мистик из клана Гнилобрюхих", -- [569]
    "Мистик из клана Мо'Грош", -- [570]
    "Мистик из стаи Гнилошкуров", -- [571]
    "Мистик из стаи Древолапов", -- [572]
    "Мистик из стаи Красногорья", -- [573]
    "Младший мертвопырь", -- [574]
    "Многозубый ворчун", -- [575]
    "Могучий волк прерий", -- [576]
    "Мозгоед", -- [577]
    "Молодая величавая виверна", -- [578]
    "Молодая пантера", -- [579]
    "Молодой грозовой ящер", -- [580]
    "Молодой кровоклык", -- [581]
    "Молодой рифовый краб", -- [582]
    "Молодой тигр Тернистой долины", -- [583]
    "Молодой шкуродер", -- [584]
    "Монах Алого ордена", -- [585]
    "Моора", -- [586]
    "Мор'Ладим", -- [587]
    "Морозная нимфа", -- [588]
    "Морская ведьма из клана Зловещего Хвоста", -- [589]
    "Морской волк из шайки Кровавого Паруса", -- [590]
    "Морта'гья Хранительница", -- [591]
    "Моряк Пламенного Крыла", -- [592]
    "Моховая паучиха", -- [593]
    "Моховой паук-вязальщик", -- [594]
    "Моховой ползун", -- [595]
    "Моховой ядоплюй", -- [596]
    "Мошенник из Братства Справедливости", -- [597]
    "Мошенник из племени Пещерных Глубин", -- [598]
    "Мрачница", -- [599]
    "Мрачница-вампир", -- [600]
    "Мрачноокий скелет-заклинатель", -- [601]
    "Мрачный охотник", -- [602]
    "Мрачный убийца", -- [603]
    "Мститель из племени Колючего Меха", -- [604]
    "Мстительная тень", -- [605]
    "Мумифицированный охотник за головами", -- [606]
    "Мурлок из племени Болотного Плавника", -- [607]
    "Мурлок из племени Илистых Плавников", -- [608]
    "Мурлок из племени Синежабрых", -- [609]
    "Мурлок-береговик", -- [610]
    "Мурлок-волнолов", -- [611]
    "Мурлок-гарпунер", -- [612]
    "Мурлок-добытчик", -- [613]
    "Мурлок-налетчик", -- [614]
    "Мурлок-оракул", -- [615]
    "Мурлок-охотник", -- [616]
    "Мурлок-разведчик", -- [617]
    "Мурлок-сетеплет", -- [618]
    "Мурлок-скрытень", -- [619]
    "Мурлок-трупоед", -- [620]
    "Мутанус Пожиратель", -- [621]
    "Мшистый паук-ловец", -- [622]
    "Мшистый ползун", -- [623]
    "Мятежник из клана Черного Железа", -- [624]
    "Наблюдатель Торговой Компании", -- [625]
    "Нага из клана Зловещей Чешуи", -- [626]
    "Нага-исследователь", -- [627]
    "Надзиратель Грязепых", -- [628]
    "Надзиратель Торговой Компании", -- [629]
    "Надзиратель Устана", -- [630]
    "Надзиратель из Братства Справедливости", -- [631]
    "Надсмотрщик Физзул", -- [632]
    "Надсмотрщик из клана Ярости Горна", -- [633]
    "Надсмотрщик пустошей", -- [634]
    "Наемник Торговой Компании", -- [635]
    "Наемник племени Зловещего Тотема", -- [636]
    "Наксрамасская тень", -- [637]
    "Налетчик Густогривов", -- [638]
    "Налетчик из клана Драконьей Пасти", -- [639]
    "Налетчик из племени Синежабрых", -- [640]
    "Налетчик из шайки Кровавого Паруса", -- [641]
    "Насылающий чуму из стаи Гнилошкуров", -- [642]
    "Невменяемый вурдалак", -- [643]
    "Неголаш", -- [644]
    "Недоросток из стаи Речной Лапы", -- [645]
    "Неживой кабан", -- [646]
    "Нежить-землечерп", -- [647]
    "Некровладыка Мезхен", -- [648]
    "Некромант Смертхольма", -- [649]
    "Некрорахнид-ползун", -- [650]
    "Ненасытная тень", -- [651]
    "Неофит Алого ордена", -- [652]
    "Неофит клана Пылающего Клинка", -- [653]
    "Непреклонный пехотинец", -- [654]
    "Неруб'арский властелин паутины", -- [655]
    "Неруб'арский затмитель небес", -- [656]
    "Неруб-страж", -- [657]
    "Неруб-центурион", -- [658]
    "Несговорчивый дух", -- [659]
    "Нестабильный труп", -- [660]
    "Нечистый ворген из стаи Ночной Погибели", -- [661]
    "Низший мурлок-волномут", -- [662]
    "Низший мурлок-оракул", -- [663]
    "Низший оракул из племени Злобного Плавника", -- [664]
    "Нисса Агамонд", -- [665]
    "Норалаский воитель", -- [666]
    "Норалаский колдун", -- [667]
    "Ночной клинок из Братства Справедливости", -- [668]
    "Ночной ловец", -- [669]
    "Ночной саблезуб", -- [670]
    "Нэнси Вишас", -- [671]
    "Оазисный хрустогрыз", -- [672]
    "Оберег лености", -- [673]
    "Обжигайка", -- [674]
    "Обжигающий тотем", -- [675]
    "Обжигающий элементаль", -- [676]
    "Обжора Лунной Ярости", -- [677]
    "Облезлый волк", -- [678]
    "Облученный погромщик", -- [679]
    "Огнегривый пеплохвост", -- [680]
    "Огнегривый разведчик", -- [681]
    "Огнепряд Драккари", -- [682]
    "Озерная бешенка", -- [683]
    "Озерный крепкозуб", -- [684]
    "Озерный ползун", -- [685]
    "Око Дар'Кхана", -- [686]
    "Опаленный василиск", -- [687]
    "Опаляющий вурдалак", -- [688]
    "Опаляющий инфернал", -- [689]
    "Опаляющий малыш дракона", -- [690]
    "Опаляющий рух", -- [691]
    "Оператор Торговой Компании", -- [692]
    "Оплавленный элементаль", -- [693]
    "Опустошитель Колючего Клыка", -- [694]
    "Опустошитель обыкновенный", -- [695]
    "Оракул Непроглядной Пучины", -- [696]
    "Оракул из клана Скользящего Плавника", -- [697]
    "Оракул из племени Илистых Плавников", -- [698]
    "Оракул из племени Рваного Плавника", -- [699]
    "Оракул из племени Соленой Слюны", -- [700]
    "Оракул племени Призрачной Сосны", -- [701]
    "Оракул племени Серой Мглы", -- [702]
    "Орденоносец Алого ордена", -- [703]
    "Оружейник из клана Укротителей драконов", -- [704]
    "Освобожденный дух", -- [705]
    "Оскверненный древень", -- [706]
    "Оскверненный кровопалый лезвезуб", -- [707]
    "Островная обезьяна", -- [708]
    "Острозубый крепкохват", -- [709]
    "Острокоготь", -- [710]
    "Отарщик из племени Колкар", -- [711]
    "Отрекшийся-телохранитель", -- [712]
    "Отродье Ула’тек", -- [713]
    "Охотник за головами Курцена", -- [714]
    "Охотник за головами из племени Дробителей Черепов", -- [715]
    "Охотник за головами из племени Мерзлогривов", -- [716]
    "Охотник за головами из племени Порочной Ветви", -- [717]
    "Охотник за головами из племени Призрачной Сосны", -- [718]
    "Охотник за головами из племени Сухокожих", -- [719]
    "Охотник из клана Черной горы", -- [720]
    "Охотник из племени Дробителей Черепов", -- [721]
    "Охотник из племени Дыбогривов", -- [722]
    "Охотник из племени Заблудших", -- [723]
    "Охотник из племени Иглогривых", -- [724]
    "Охотник из племени Илистых Плавников", -- [725]
    "Охотник из племени Кровавого Скальпа", -- [726]
    "Охотник прерий", -- [727]
    "Охотница саванны", -- [728]
    "Охранник Торговой Компании", -- [729]
    "Охранник из клана Ярости Горна", -- [730]
    "Павший следопыт", -- [731]
    "Пагубная слизь", -- [732]
    "Падальщик-отшельник", -- [733]
    "Падальщик-чернолап", -- [734]
    "Палач Корнелл", -- [735]
    "Пантера", -- [736]
    "Пантера джунглей", -- [737]
    "Пантера племени Дробителей Черепов", -- [738]
    "Панцирный скорпид", -- [739]
    "Партизан Курцена", -- [740]
    "Паршивая гиена", -- [741]
    "Паршивый рыкун", -- [742]
    "Пастух из племени Колкар", -- [743]
    "Патриарх Скального гнездовья", -- [744]
    "Патрульная башни из Братства Справедливости", -- [745]
    "Паук Мглистой пещеры", -- [746]
    "Паук-скакун дикого терна", -- [747]
    "Паучиха-кровопийца", -- [748]
    "Паучонок Мглистой пещеры", -- [749]
    "Пачкун из племени Синежабрых", -- [750]
    "Певчая из стаи Кораллового Когтя", -- [751]
    "Перебежчик из клана Черной горы", -- [752]
    "Передовой боец Алого ордена", -- [753]
    "Песчаная акула", -- [754]
    "Песчаный краб", -- [755]
    "Пещерный скорпид", -- [756]
    "Пират Южных Морей", -- [757]
    "Пират из Братства Справедливости", -- [758]
    "Пиромант Зерно Мудрости", -- [759]
    "Плакальщица", -- [760]
    "Пламенный страж из племени Галак", -- [761]
    "Плеть ночи", -- [762]
    "Плотоглот нагорья", -- [763]
    "Плотояд", -- [764]
    "Плут из племени Каменного Сердца", -- [765]
    "Плутоватый маг", -- [766]
    "Побережник из клана Пронзающего Гребня", -- [767]
    "Повелитель животных из племени Призрачной Сосны", -- [768]
    "Повелитель приливов из племени Соленой Чешуи", -- [769]
    "Погромщик из Братства Справедливости", -- [770]
    "Подручный Каргата", -- [771]
    "Подрывник из клана Черного Железа", -- [772]
    "Подчинитель из клана Гэрдан", -- [773]
    "Покалеченный хранитель", -- [774]
    "Покрытый илом краб", -- [775]
    "Ползун", -- [776]
    "Ползучий силитид", -- [777]
    "Ползучий слякоч", -- [778]
    "Полководец Кром'зар", -- [779]
    "Полукровка из стаи Древолапов", -- [780]
    "Полукровка из стаи Красногорья", -- [781]
    "Полукровка из стаи Мохошкуров", -- [782]
    "Полярный гризли", -- [783]
    "Помощник Курцена", -- [784]
    "Поработитель из клана Дробящего Кулака", -- [785]
    "Поработитель из клана Черного Железа", -- [786]
    "Порабощенный пожинатель", -- [787]
    "Порождение Света", -- [788]
    "Порочный приливный краб", -- [789]
    "Портной деревни Погребальных Костров", -- [790]
    "Посвященный душелов", -- [791]
    "Посланник из клана Черного Железа", -- [792]
    "Послушник из Смертхольма", -- [793]
    "Послушник клана Пылающего Клинка", -- [794]
    "Потрошительница", -- [795]
    "Предатель из племени Ярой Ненависти", -- [796]
    "Предвестница бури из племени Колкар", -- [797]
    "Презренный-бесчинник", -- [798]
    "Презренный-исследователь", -- [799]
    "Преступник Синдиката", -- [800]
    "Преступник из Братства Справедливости", -- [801]
    "Призрак Ликкаты", -- [802]
    "Призрак из племени Маграм", -- [803]
    "Призрак кель'дорайского мага", -- [804]
    "Призрачный горожанин", -- [805]
    "Призыватель Огня из племени Песчаной Бури", -- [806]
    "Призыватель из клана Пылающего Клинка", -- [807]
    "Призыватель из клана Черной горы", -- [808]
    "Призыватель огня из племени Змеящегося Корня", -- [809]
    "Призыватель огня из племени Ксавиан", -- [810]
    "Призывательница ветров из стаи Зачарованного Крыла", -- [811]
    "Призывательница ветров из стаи Кровавой Ярости", -- [812]
    "Принц Рейз", -- [813]
    "Прирученная гиена", -- [814]
    "Прислужник-демон Бездны", -- [815]
    "Провидец Тенетопи", -- [816]
    "Прожорень Темного Клыка", -- [817]
    "Прокаженный ассистент", -- [818]
    "Проклятый из племени Заблудших", -- [819]
    "Проклятый матрос", -- [820]
    "Проклятый пес тьмы", -- [821]
    "Проклятый страж бухты", -- [822]
    "Проклятый тролль", -- [823]
    "Просоленный взорень", -- [824]
    "Проходимец Синдиката", -- [825]
    "Проходимец из Братства Справедливости", -- [826]
    "Проходчик из клана Черного Железа", -- [827]
    "Проходчик-сентипаар", -- [828]
    "Псарь Локси", -- [829]
    "Птенец грозового змея", -- [830]
    "Пузырящийся болотный слизнюк", -- [831]
    "Пума плоскогорья", -- [832]
    "Пшикс Чернолап", -- [833]
    "Пылающий опустошитель", -- [834]
    "Пыледемон", -- [835]
    "Раб Когтя Ворона", -- [836]
    "Раб-трудяга", -- [837]
    "Рабочий Сапфирного улья", -- [838]
    "Рабочий Торговой Компании", -- [839]
    "Рабочий из Братства Справедливости", -- [840]
    "Равнинный ползун", -- [841]
    "Раджа Хагхазед", -- [842]
    "Радисон Призыватель Огня", -- [843]
    "Радужный изгнанник", -- [844]
    "Разбойник Синдиката", -- [845]
    "Разбойник из племени Ксавиан", -- [846]
    "Разбойник из шайки Скитальцев Пустыни", -- [847]
    "Разбойник-дух огня", -- [848]
    "Разбойница из стаи Зачарованного Крыла", -- [849]
    "Разведчик из клана Драконьей Пасти", -- [850]
    "Разведчик из племени Камнедробов", -- [851]
    "Разведчик из племени Кровавого Скальпа", -- [852]
    "Разведчик из племени Черного Ила", -- [853]
    "Разведчик из стаи Речной Лапы", -- [854]
    "Разведчик-туннельщик", -- [855]
    "Разоритель из клана Драконьей Пасти", -- [856]
    "Разоритель из пещерных глубин", -- [857]
    "Разоритель из племени Зловещего Тотема", -- [858]
    "Разрушитель из племени Колкар", -- [859]
    "Разъяренная пантера", -- [860]
    "Разъяренный каменный элементаль", -- [861]
    "Разъяренный сокрушитель", -- [862]
    "Рак'Зор", -- [863]
    "Рао-Минь Покоритель", -- [864]
    "Распорядитель из клана Гэрдан", -- [865]
    "Распространитель чумы", -- [866]
    "Раториан", -- [867]
    "Ревелош", -- [868]
    "Резонирующее отродье", -- [869]
    "Ремонтник Торговой Компании", -- [870]
    "Речной мурлок-бегун", -- [871]
    "Ржавый уборочный голем", -- [872]
    "Рифовый краб", -- [873]
    "Рубака из Павшего Молота", -- [874]
    "Рубака из клана Драконьей Пасти", -- [875]
    "Рубака из клана Черной горы", -- [876]
    "Рубака клана Изувеченной Длани", -- [877]
    "Ружейник Дун Гарока", -- [878]
    "Рунический разоритель", -- [879]
    "Руул Светокрад", -- [880]
    "Саботажник из клана Солнечного Ястреба", -- [881]
    "Саботажник из клана Черного Железа", -- [882]
    "Сарыч", -- [883]
    "Сатир из племени Дет'рилл", -- [884]
    "Сатир из племени Змеящегося Корня", -- [885]
    "Светлолапый вожак", -- [886]
    "Светлолапый ревун", -- [887]
    "Светлопалая рысь", -- [888]
    "Светлопалый опустошитель", -- [889]
    "Свинеар Копьешкур", -- [890]
    "Свиностраж племени Иглошкурых", -- [891]
    "Северный нетопырь-крикун", -- [892]
    "Севрисс", -- [893]
    "Седой колючешерстный медведь", -- [894]
    "Седой черный медведь", -- [895]
    "Секретный агент-часовой", -- [896]
    "Сектант бастиона Вечной Скорби", -- [897]
    "Сектант из клана Пламенеющего Клинка", -- [898]
    "Сектант из клана Пылающего Клинка", -- [899]
    "Сердитый краб", -- [900]
    "Сестра Горя", -- [901]
    "Силитид-захватчик", -- [902]
    "Сирена из клана Гремучей Чешуи", -- [903]
    "Сирена из клана Пронзающего Гребня", -- [904]
    "Скальный койот", -- [905]
    "Скальный охотник", -- [906]
    "Скарабей", -- [907]
    "Сквернобот", -- [908]
    "Сквернопламенный деметродон", -- [909]
    "Скверноподданный из клана Пылающего Клинка", -- [910]
    "Скверноподданный из племени Ксавиан", -- [911]
    "Скверноподданный из племени Отравленного Сердца", -- [912]
    "Скелет Занзила", -- [913]
    "Скелет-губитель", -- [914]
    "Скелет-живодер", -- [915]
    "Скелет-колдун", -- [916]
    "Скелет-лекарь", -- [917]
    "Скелет-налетчик", -- [918]
    "Скелет-послушник", -- [919]
    "Скелет-хранитель", -- [920]
    "Скелет-шахтер", -- [921]
    "Скользкопанцирный макрура", -- [922]
    "Скользящий по волнам из клана Гребня Ненависти", -- [923]
    "Скользящий по волнам из клана Гремучей Чешуи", -- [924]
    "Скорбящая плакальщица", -- [925]
    "Скорпид-охотник", -- [926]
    "Скорпид-разоритель", -- [927]
    "Скорпид-убийца", -- [928]
    "Скрежетун", -- [929]
    "Слабый обжигающий тотем", -- [930]
    "Следопыт из клана Черной горы", -- [931]
    "Слуга Аку'май", -- [932]
    "Слуга Анту'сула", -- [933]
    "Слуга Когтя Ворона", -- [934]
    "Слуга Хоргуса", -- [935]
    "Служитель племени Иглошкурых", -- [936]
    "Слюнявый вурдалак", -- [937]
    "Смертехват нагорья", -- [938]
    "Смертоносный тарантул", -- [939]
    "Смеющаяся сестра", -- [940]
    "Снежный леопард", -- [941]
    "Солдат Алого ордена", -- [942]
    "Солдат Бейл'дана", -- [943]
    "Солдат Дун Гарока", -- [944]
    "Солдат-наемник из клана Мош'Огг", -- [945]
    "Солдат-наемник из клана Раздробленного Хребта", -- [946]
    "Солончаковый падальщик", -- [947]
    "Спутник Братства Справедливости", -- [948]
    "Среброгривый бродяга", -- [949]
    "Старая горилла Мглистой долины", -- [950]
    "Старая тенебрюхая пантера", -- [951]
    "Старейшина Лунной Ярости", -- [952]
    "Старший волхв из шайки Кровавого Паруса", -- [953]
    "Старый Ледобород", -- [954]
    "Старый Мрачноглаз", -- [955]
    "Старый облачный змей", -- [956]
    "Старый тенерог", -- [957]
    "Старый тигр Тернистой долины", -- [958]
    "Стежок", -- [959]
    "Стенающая прародительница", -- [960]
    "Стенающий охранник", -- [961]
    "Сторож Синдиката", -- [962]
    "Страж Аман'заси из племени Порочной Ветви", -- [963]
    "Страж Когтя Ворона", -- [964]
    "Страж бухты Северного флота", -- [965]
    "Страж гнева", -- [966]
    "Страж-смотритель из племени Иглошкурых", -- [967]
    "Стражник улья Гориши", -- [968]
    "Странствующий дух", -- [969]
    "Странствующий страж Скверны", -- [970]
    "Стрелок высокодолья", -- [971]
    "Суккуб-прислужница", -- [972]
    "Сумасшедший Абдул", -- [973]
    "Сумеречный аквамант", -- [974]
    "Сумеречный бегун", -- [975]
    "Сумеречный истязатель", -- [976]
    "Сумеречный лиходей", -- [977]
    "Сумеречный пророк", -- [978]
    "Сумеречный разоритель", -- [979]
    "Сумеречный хранитель Хавунт", -- [980]
    "Сумеречный эмиссар", -- [981]
    "Сурена Каледон", -- [982]
    "Сухолистый ползун", -- [983]
    "Сушимастер Найтфорт", -- [984]
    "Сын Аругала", -- [985]
    "Сын Корока", -- [986]
    "Тан клана Укротителей драконов", -- [987]
    "Тарантул", -- [988]
    "Таргорр Ужасный", -- [989]
    "Тарил'зун", -- [990]
    "Тварь маны", -- [991]
    "Твердозуб из стаи Красногорья", -- [992]
    "Твердозуб нагорья", -- [993]
    "Телохранитель из Багрового Легиона", -- [994]
    "Темноплет из стаи Темношкуров", -- [995]
    "Темнорожденный паучок", -- [996]
    "Темный жрец из племени Амани", -- [997]
    "Темный маг Синдиката", -- [998]
    "Темный маг из шайки Скитальцев Пустыни", -- [999]
    "Темный охотник из клана Песчаной Бури", -- [1000]
    "Темный охотник из племени Порочной Ветви", -- [1001]
    "Темный охотник из племени Тлеющего Терновника", -- [1002]
    "Темный следопыт", -- [1003]
    "Темный чародей из клана Черной горы", -- [1004]
    "Темный чародей из племени Песчаной Бури", -- [1005]
    "Темный чародей племени Мерзлогривов", -- [1006]
    "Тенебрюхая пантера", -- [1007]
    "Тенегорнский бузотер", -- [1008]
    "Тенегорнский землекоп", -- [1009]
    "Тенегорнский охотник за реликвиями", -- [1010]
    "Тенелов из племени Кабарог Скверны", -- [1011]
    "Тенеткач Ночной Погибели", -- [1012]
    "Тень Феллисенты", -- [1013]
    "Тераморская оберегательница", -- [1014]
    "Тераморский страж бухты", -- [1015]
    "Терзаемый высокорожденный", -- [1016]
    "Терноплет из племени Дыбогривов", -- [1017]
    "Терноплет из племени Иглогривых", -- [1018]
    "Тероккарантул", -- [1019]
    "Терорекс", -- [1020]
    "Терроволк-шкуродер", -- [1021]
    "Терровульф-тенеплет", -- [1022]
    "Тигр Тернистой долины", -- [1023]
    "Тигр племени Кровавого Скальпа", -- [1024]
    "Тигрица Тернистой долины", -- [1025]
    "Тиноброд", -- [1026]
    "Ткач туманов из стаи Мохошкуров", -- [1027]
    "Топехлыст", -- [1028]
    "Топотун Железнолесья", -- [1029]
    "Топотун из племени Зловещего Тотема", -- [1030]
    "Тора Оперенная Луна", -- [1031]
    "Тоскующий мертвец", -- [1032]
    "Тотемист из племени Гиблой Чащи", -- [1033]
    "Тотемист из племени Кривой Сосны", -- [1034]
    "Тотемист из племени Чернолесья", -- [1035]
    "Трезвый защитник клана Камнерогов", -- [1036]
    "Трогг Огненной пропасти", -- [1037]
    "Трогг из племени Камнедробов", -- [1038]
    "Тролль из племени Сухокожих", -- [1039]
    "Тропическая пантера", -- [1040]
    "Тропический ловец", -- [1041]
    "Трясинный кроколиск", -- [1042]
    "Трясинный ползун", -- [1043]
    "Туннельщик из племени Ветрорезов", -- [1044]
    "Тюремный надзиратель Эстон", -- [1045]
    "Тюремщик Янтарной мельницы", -- [1046]
    "Убийца из Синдиката", -- [1047]
    "Убийца из клана Темной Нити", -- [1048]
    "Убийца из племени Галак", -- [1049]
    "Убийца из шайки Скитальцев Пустыни", -- [1050]
    "Уборочный голем", -- [1051]
    "Ужасающий кондор", -- [1052]
    "Укрощенный медведь Амани", -- [1053]
    "Ун'горский рокотун", -- [1054]
    "Уничтоженный кадавр", -- [1055]
    "Уничтожитель из клана Костеглодов", -- [1056]
    "Ургрет из Тысячи Могил", -- [1057]
    "Уродливый трупоед", -- [1058]
    "Ученик Блеклых Сумерек", -- [1059]
    "Ученик клана Пылающего Клинка", -- [1060]
    "Фал'дорайская прядильщица", -- [1061]
    "Фал'дорайский страж выводка", -- [1062]
    "Фанатик из клана Пылающего Клинка", -- [1063]
    "Фанатик из клана Темной Нити", -- [1064]
    "Фардел Дабири", -- [1065]
    "Фенвик Татрос", -- [1066]
    "Финансист Снотц", -- [1067]
    "Фозрук", -- [1068]
    "Фурболг из племени Чернолесья", -- [1069]
    "Хадронокс", -- [1070]
    "Хай'шулуд", -- [1071]
    "Харли Чернопых", -- [1072]
    "Хилсбрадский караульный", -- [1073]
    "Хилсбрадский крестьянин", -- [1074]
    "Хилсбрадский пехотинец", -- [1075]
    "Хилсбрадский фермер", -- [1076]
    "Хилсбрадский шахтер", -- [1077]
    "Хилсбрадский штейгер", -- [1078]
    "Хитрый волшебный дракончик", -- [1079]
    "Хищник саванны", -- [1080]
    "Хищный землерой", -- [1081]
    "Хищный скелет", -- [1082]
    "Храмовый воин Тики", -- [1083]
    "Хранитель Мутного озера", -- [1084]
    "Хранитель Ордан", -- [1085]
    "Хранитель скал из племени Камнепадов", -- [1086]
    "Хранитель теней из клана Драконьей Пасти", -- [1087]
    "Хромоног", -- [1088]
    "Хрустогрыз", -- [1089]
    "Хэзрул Кровавая Отметина", -- [1090]
    "Царственный синий бражник", -- [1091]
    "Целитель Драккари", -- [1092]
    "Центурион-костещеп", -- [1093]
    "Циклониан", -- [1094]
    "Чародей Доан", -- [1095]
    "Чарокнижник Янтарной мельницы", -- [1096]
    "Чароплет Алого ордена", -- [1097]
    "Чаротвор Мош'Огг", -- [1098]
    "Чаротворец из Братства Справедливости", -- [1099]
    "Часовой-шпион", -- [1100]
    "Чащобный древотес", -- [1101]
    "Чащобный злобноклюв", -- [1102]
    "Чащобный призыватель дождя", -- [1103]
    "Чащобный ядоклык", -- [1104]
    "Чеканщик из племени Гелкис", -- [1105]
    "Черная Охотница", -- [1106]
    "Чернозлоб Лунной Ярости", -- [1107]
    "Чернокнижник из клана Песчаного Молота", -- [1108]
    "Чернокнижник из шайки Кровавого Паруса", -- [1109]
    "Чернокнижник клана Черной горы", -- [1110]
    "Чернорабочий Когтя Ворона", -- [1111]
    "Чернорабочий Торговой Компании", -- [1112]
    "Чернорабочий из племени Отребья", -- [1113]
    "Черношкур-старший", -- [1114]
    "Черный дракончик", -- [1115]
    "Черный маг Смертхольма", -- [1116]
    "Черный медведь", -- [1117]
    "Черный опустошитель", -- [1118]
    "Черный слизнюк", -- [1119]
    "Черный страж из Братства Справедливости", -- [1120]
    "Член совета Брансвик", -- [1121]
    "Член совета Вильгельм", -- [1122]
    "Член совета Купер", -- [1123]
    "Член совета Хилсбрада", -- [1124]
    "Чок'сул", -- [1125]
    "Чудовищный слизнюк", -- [1126]
    "Чумнокостный погромщик", -- [1127]
    "Чумобрюх Гнилой", -- [1128]
    "Шадра", -- [1129]
    "Шаман Огненной пропасти", -- [1130]
    "Шаман из клана Мош'Огг", -- [1131]
    "Шаман из племени Камнедробов", -- [1132]
    "Шаман из племени Колючего Меха", -- [1133]
    "Шаман из племени Косолапов", -- [1134]
    "Шаман из племени Кривой Сосны", -- [1135]
    "Шаман из племени Чернолесья", -- [1136]
    "Шаман из стаи Грязного Рыла", -- [1137]
    "Шаман из стаи Речной Лапы", -- [1138]
    "Шаман клана Тяжелого Кулака", -- [1139]
    "Шаман-чернолап", -- [1140]
    "Шаркающий ужас", -- [1141]
    "Шахтер из Братства Справедливости", -- [1142]
    "Шахтер из стаи Речной Лапы", -- [1143]
    "Шиенорский когант", -- [1144]
    "Шкуродер", -- [1145]
    "Шкуродер из племени Мерзлогривов", -- [1146]
    "Шкуродер из племени Порочной Ветви", -- [1147]
    "Шпион Синдиката", -- [1148]
    "Шпион из клана Солнечного Ястреба", -- [1149]
    "Шпион из клана Черного Железа", -- [1150]
    "Штейгер Грилз", -- [1151]
    "Штейгер Коззл", -- [1152]
    "Эктоплазма кошмаров", -- [1153]
    "Элементаль земли", -- [1154]
    "Эльф крови-бандит", -- [1155]
    "Эмиссар Роман'хан", -- [1156]
    "Эрлан Драджмур", -- [1157]
    "Южный песчаный краб", -- [1158]
    "Юный дракончик", -- [1159]
    "Ядовитый кругопряд", -- [1160]
    "Ядоплюй Колючего Клыка", -- [1161]
    "Ядохвостый скорпид", -- [1162]
    "Ян \"Проныра\" Тапоке", -- [1163]
    "Яркочешуйчатый кнутохвост", -- [1164]
    "Яркочешуйчатый крикун", -- [1165]
    "Яркочешуйчатый смертехват", -- [1166]
    "Ярозуб Темного Клыка", -- [1167]
    "Яростный Коготь", -- [1168]
    "Ярый Клык Ночной Погибели", -- [1169]
    "Ясновидец из племени Камнедробов", -- [1170]
    "Ясновидец из племени Серой Мглы", -- [1171]
    "Ящер-кнутохвост", -- [1172]
}

for i, mobName in ipairs(uniqueMobNamesCause7) do
    ns.MobNameByID[i] = mobName
    ns.MobIDByName[mobName] = i
end

-- For debugging, print the generated tables (optional)
-- print("ns.MobNameByID = {")
-- for id, name in pairs(ns.MobNameByID) do
--     print(string.format("    [%d] = \"%s\",", id, name:gsub("\"", "\\\""))) -- Escape quotes in names
-- end
-- print("}")

-- print("\nns.MobIDByName = {")
-- for name, id in pairs(ns.MobIDByName) do
--     print(string.format("    [\"%s\"] = %d,", name:gsub("\"", "\\\""), id)) -- Escape quotes in names
-- end
-- print("}")

-- in Utils.lua (once):
ns.ClassNameByID = {
    [1] = "WARRIOR",
    [2] = "PALADIN",
    [3] = "HUNTER",
    [4] = "ROGUE",
    [5] = "PRIEST",
    [7] = "SHAMAN",
    [8] = "MAGE",
    [9] = "WARLOCK",
    [11] = "DRUID",
}
ns.ClassIDByName = {}
for id, name in pairs(ns.ClassNameByID) do
    ns.ClassIDByName[name] = id
end

ns.DeathCauseByID = {
    [0] = "Усталость",
    [1] = "Утопление",
    [2] = "Падение",
    [3] = "Лава",
    [4] = "Слизь",
    [5] = "Огонь",
    [6] = "Падение в бездну",
    [7] = "существом", -- this one uses mob name instead
    [8] = "Умер в PVP схватке",
    [9] = "Погиб от действий союзника",
    [10] = "Погиб от собственных действий",
}

function ns.GetDeathCauseByID(id, mobName)
    if id == 7 and mobName and mobName ~= "" then
        return mobName
    else
        return ns.DeathCauseByID[id] or ("UnknownCause(" .. tostring(id) .. ")")
    end
end

ns.RaceInfoByID = {
    [1] = { name = "Человек", faction = "Alliance" },
    [2] = { name = "Орк", faction = "Horde" },
    [3] = { name = "Дворф", faction = "Alliance" },
    [4] = { name = "Ночной эльф", faction = "Alliance" },
    [5] = { name = "Нежить", faction = "Horde" },
    [6] = { name = "Таурен", faction = "Horde" },
    [7] = { name = "Гном", faction = "Alliance" },
    [8] = { name = "Тролль", faction = "Horde" },
    [9] = { name = "Гоблин", faction = "Horde" },
    [10] = { name = "Эльф крови", faction = "Horde" },
    [11] = { name = "Дреней", faction = "Alliance" },
    [12] = { name = "Ворген", faction = "Alliance" },
    [13] = { name = "Нага", faction = "Horde" },
    [14] = { name = "Пандарен", faction = "Alliance" },
    [15] = { name = "Высший эльф", faction = "Alliance" },
    [16] = { name = "Пандарен", faction = "Horde" },
    [17] = { name = "Ночноро\nждённый", faction = "Horde" },
    [18] = { name = "Эльф Бездны", faction = "Alliance" },
    [19] = { name = "Вульпера", faction = "Alliance" },
    [20] = { name = "Вульпера", faction = "Horde" },
    [21] = { name = "Вульпера", faction = "Neutral" },
    [22] = { name = "Пандарен", faction = "Neutral" },
    [23] = { name = "Зандалар", faction = "Horde" },
    [24] = { name = "Озар. дреней", faction = "Alliance" },
    [25] = { name = "Эредар", faction = "Horde" },
    [26] = { name = "Дворф Ч. Железа", faction = "Alliance" },
    [27] = { name = "Драктир", faction = "Horde" }
}

-- Build race name → ID map for the sender
ns.RaceIDByName = {}
for id, info in pairs(ns.RaceInfoByID) do
    ns.RaceIDByName[info.name] = id
end

-- Helper: get race info by code
function ns.GetRaceInfoByID(id)
    return ns.RaceInfoByID[id] or { name = ("UnknownRace(%d)"):format(id), faction = nil }
end

-- Only the “world” zones (zoneID → localized name)
ns.ZoneNameByID = {
    [4] = "Дуротар",
    [9] = "Мулгор",
    [11] = "Степи",
    [15] = "Альтеракские горы",
    [16] = "Нагорье Арати",
    [17] = "Бесплодные земли",
    [19] = "Выжженные земли",
    [20] = "Тирисфальские леса",
    [21] = "Серебряный бор",
    [22] = "Западные Чумные земли",
    [23] = "Восточные Чумные земли",
    [24] = "Предгорья Хилсбрада",
    [26] = "Внутренние земли",
    [27] = "Дун Морог",
    [28] = "Тлеющее ущелье",
    [29] = "Пылающие степи",
    [30] = "Элвиннский лес",
    [32] = "Перевал Мертвого Ветра",
    [34] = "Сумеречный лес",
    [35] = "Лок Модан",
    [36] = "Красногорье",
    [37] = "Тернистая долина",
    [38] = "Болото Печали",
    [39] = "Западный Край",
    [40] = "Болотина",
    [41] = "Тельдрассил",
    [42] = "Темные берега",
    [43] = "Ясеневый лес",
    [61] = "Тысяча Игл",
    [81] = "Когтистые горы",
    [101] = "Пустоши",
    [121] = "Фералас",
    [141] = "Пылевые топи",
    [161] = "Танарис",
    [181] = "Азшара",
    [182] = "Оскверненный лес",
    [201] = "Кратер Ун'Горо",
    [241] = "Лунная поляна",
    [261] = "Силитус",
    [281] = "Зимние Ключи",
    [301] = "Штормград",
    [321] = "Оргриммар",
    [341] = "Стальгорн",
    [362] = "Громовой Утес",
    [381] = "Дарнас",
    [382] = "Подгород",
    [401] = "Альтеракская долина",
    [443] = "Ущелье Песни Войны",
    [461] = "Низина Арати",
    [462] = "Леса Вечной Песни",
    [463] = "Призрачные земли",
    [464] = "Остров Лазурной Дымки",
    [465] = "Полуостров Адского Пламени",
    [467] = "Зангартопь",
    [471] = "Экзодар",
    [473] = "Долина Призрачной Луны",
    [475] = "Острогорье",
    [476] = "Остров Кровавой Дымки",
    [477] = "Награнд",
    [478] = "Лес Тероккар",
    [479] = "Пустоверть",
    [480] = "Луносвет",
    [481] = "Шаттрат",
    [482] = "Око Бури",
    [486] = "Борейская тундра",
    [488] = "Драконий Погост",
    [490] = "Седые холмы",
    [491] = "Ревущий фьорд",
    [492] = "Ледяная Корона",
    [493] = "Низина Шолазар",
    [495] = "Грозовая Гряда",
    [496] = "Зул'Драк",
    [499] = "Остров Кель'Данас",
    [501] = "Озеро Ледяных Оков",
    [502] = "Чумные земли: Анклав Алого ордена",
    [504] = "Даларан",
    [510] = "Лес Хрустальной Песни",
    [512] = "Берег Древних",
    [520] = "Нексус",
    [521] = "Очищение Стратхольма",
    [522] = "Ан'кахет: Старое Королевство",
    [523] = "Крепость Утгард",
    [524] = "Вершина Утгард",
    [525] = "Чертоги Молний",
    [526] = "Чертоги Камня",
    [527] = "Око Вечности",
    [528] = "Окулус",
    [529] = "Ульдуар",
    [530] = "Гундрак",
    [531] = "Обсидиановое святилище",
    [532] = "Склеп Аркавона",
    [533] = "Азжол-Неруб",
    [534] = "Крепость Драк'Тарон",
    [535] = "Наксрамас",
    [536] = "Аметистовая крепость",
    [540] = "Остров Завоеваний",
    [541] = "Лагерь Хротгара",
    [542] = "Испытание чемпиона",
    [543] = "Испытание крестоносца",
    [601] = "Кузня Душ",
    [602] = "Яма Сарона",
    [603] = "Залы Отражений",
    [604] = "Цитадель Ледяной Короны",
    [609] = "Рубиновое святилище",
    [610] = "Долина Узников",
    [680] = "Огненная пропасть",
    [687] = "Храм Атал'Хаккара",
    [718] = "Логово Ониксии",
    [722] = "Аукенайские гробницы",
    [749] = "Пещеры Стенаний",
    [833] = "Сетеккские залы",
    [834] = "Темный лабиринт",
    [835] = "Кузня Крови",
    [836] = "Нижетопь",
    [837] = "Паровое подземелье",
    [838] = "Узилище",
    [839] = "Ботаника",
    [840] = "Механар",
    [841] = "Аркатрац",
    [842] = "Гробницы Маны",
    [843] = "Разрушенные залы",
    [844] = "Черные топи",
    [845] = "Старые предгорья Хилсбрада",
    [846] = "Плато Солнечного Колодца",
    [847] = "Черный храм",
    [848] = "Бастионы Адского Пламени",
    [849] = "Терраса Магистров",
    [860] = "Сверкающие копи",
    [861] = "Крепость Бурь",
    [862] = "Змеиное святилище",
    [863] = "Вершина Хиджала",
    [864] = "Логово Груула",
    [865] = "Логово Магтеридона",
    [866] = "Зул'Аман",
    [867] = "Каражан",
    [869] = "Хиджал",
    [871] = "Зул'Фаррак",
    [873] = "Непроглядная Пучина",
    [874] = "Тюрьма",
    [875] = "Гномреган",
    [876] = "Ульдаман",
    [877] = "Огненные Недра",
    [879] = "Забытый Город",
    [880] = "Глубины Черной горы",
    [881] = "Руины Ан'Киража",
    [882] = "Пик Черной горы",
    [884] = "Мародон",
    [885] = "Логово Крыла Тьмы",
    [886] = "Мертвые копи",
    [887] = "Курганы Иглошкурых",
    [888] = "Лабиринты Иглошкурых",
    [889] = "Монастырь Алого Ордена - Кладбище",
    [890] = "Некроситет",
    [891] = "Крепость Темного Клыка",
    [892] = "Стратхольм",
    [893] = "Ан'Кираж",
    [896] = "Клоака",
    [897] = "Затерянный остров",
    [899] = "Поднявшиеся глубины",
    [904] = "Цитадель Ледяной Короны",
    [905] = "Нексус",
    [906] = "Остров Форбс",
    [907] = "Ко'Танг",
    [908] = "Серебряный бор",
    [909] = "Гарнизон Альянса",
    [910] = "Гарнизон Альянса",
    [911] = "Гарнизон Орды",
    [912] = "Гарнизон Орды",
    [913] = "Пустота",
    [914] = "Утёсы Пыльного ветра",
    [915] = "Битва за Гилнеас",
    [916] = "Храм Котмогу",
    [917] = "Храмовый город Ала'ваште",
    [918] = "Остров Погоды",
    [920] = "Лес Великанов",
    [921] = "Ярнвид",
    [922] = "Хаустлунд",
    [923] = "Чаща Проклятых",
    [924] = "Бронзовое святилище",
    [925] = "Мертвые копи",
    [926] = "Извержение",
    [927] = "Чащоба",
    [928] = "Обитель Холода",
    [929] = "Место встречи Триумвирата",
    [930] = "Ущелье Скрытого",
    [931] = "Логово замерзшего снеговика",
    [932] = "Два Пика",
    [933] = "Черная гора",
    [934] = "Черная гора",
    [935] = "Черная гора",
    [936] = "Монастырь Алого Ордена",
    [937] = "Пещеры Стенаний",
    [938] = "Монастырь Алого Ордена - Библиотека",
    [939] = "Монастырь Алого Ордена - Оружейная",
    [940] = "Монастырь Алого Ордена - Собор",
    [941] = "Шар'гел",
    [945] = "Тол'Гарод",
    [946] = "Подземный поезд",
    [947] = "Огненный холм",
    [948] = "Осквернённый Край",
    [949] = "Тронхейм",
    [950] = "Остров Западного Ветра",
    [951] = "Длань Ходира",
    [952] = "Копье Гиннунга и Покой Гролана",
    [953] = "Нордерон",
    [954] = "Тол'Гародская тюрьма",
    [955] = "Гилнеас",
    [956] = "Хрупкий пол",
    [957] = "Зимняя Низина Арати",
    [958] = "Остров Лунар",
    [959] = "Ущелье Песни Войны",
    [960] = "Око Бури",
    [962] = "Альтеракская долина",
    [963] = "Андраккис",
    [964] = "Зул'Гуруб",
    [971] = "Безжалостные Дюны",
    [972] = "Дикие Чащобы",
    [974] = "Рао-Дан",
    [975] = "Ломая двери",
    [976] = "На грани",
    [977] = "Эльдранил",
    [979] = "Нордерон",
    [980] = "Гилнеас",
    [981] = "Цветной захват",
    [982] = "Подпольный колизей Рисона",
    [983] = "Остров Изгнанников",
    [990] = "Цитадель Темного Молота",
    [993] = "Руины Нораласа"
}

-- Invert for sender: localized zone name → zoneID
ns.ZoneIDByName = {}
for id, name in pairs(ns.ZoneNameByID) do
    ns.ZoneIDByName[name] = id
end

-- Helper: lookup zone name from ID
function ns.GetZoneNameByID(id)
    return ns.ZoneNameByID[id] or ("Неизвестно(" .. tostring(id) .. ")")
end

-- ============================================================================
-- 2) Realm lookup: short key → numeric Blizzard realm ID
--    (from E_REALM_ID on Sirus / 3.3.5)
-- ============================================================================
-- exact Blizzard GetRealmName() → numeric Sirus ID
ns.RealmFullNameToID = {
    ["Soulseeker x1 - 3.3.5a+"] = 42,
    ["Sirus"] = 57,
    ["Neltharion"] = 21,
    ["Frostmourne"] = 16,
    ["Legacy x10"] = 5,
    ["Scourge"] = 9,
    ["Algalon"] = 33,
    -- add any other exact realm strings here
}

-- invert it: numeric ID → full Blizzard realm string
ns.RealmIDToFullName = {}
for fullname, id in pairs(ns.RealmFullNameToID) do
    ns.RealmIDToFullName[id] = fullname
end

-- helper: lookup ID → full name
function ns.GetRealmNameByID(id)
    return ns.RealmIDToFullName[id] or ("UnknownRealm(" .. tostring(id) .. ")")
end

-- backport from ClassicAPI by Tsoukie
local InitalGTPSCall
local function GetTimePreciseSec()
    local Time = GetTime()
    if InitalGTPSCall == nil then
        InitalGTPSCall = Time
    end
    return Time - InitalGTPSCall
end

local COMM_PREFIX = "OFAuctionHouse"
local OF_COMM_PREFIX = "OnlyFangsAddon"
local T_AUCTION_STATE_REQUEST = "AUCTION_STATE_REQUEST"
local T_AUCTION_STATE = "AUCTION_STATE"

local T_CONFIG_REQUEST = "CONFIG_REQUEST"
local T_CONFIG_CHANGED = "CONFIG_CHANGED"

local T_AUCTION_ADD_OR_UPDATE = "AUCTION_ADD_OR_UPDATE"
local T_AUCTION_SYNCED = "AUCTION_SYNCED"
local T_AUCTION_DELETED = "AUCTION_DELETED"

-- Ratings
local T_RATING_ADD_OR_UPDATE = "RATING_ADD_OR_UPDATE"
local T_RATING_DELETED = "RATING_DELETED"
local T_RATING_SYNCED = "RATING_SYNCED"

-- LFG (Looking for Group)
ns.T_LFG_ADD_OR_UPDATE = "LFG_ADD_OR_UPDATE"
ns.T_LFG_DELETED = "LFG_DELETED"
ns.T_LFG_SYNCED = "LFG_SYNCED"
ns.T_ON_LFG_STATE_UPDATE = "OnLFGStateUpdate"
ns.T_LFG_STATE_REQUEST = "LFG_STATE_REQUEST"
ns.T_LFG_STATE = "LFG_STATE"

-- 1) Add new constants for BLACKLIST in the same style as LFG or trades.
local T_BLACKLIST_STATE_REQUEST = "BLACKLIST_STATE_REQUEST"
local T_BLACKLIST_STATE = "BLACKLIST_STATE"
local T_BLACKLIST_ADD_OR_UPDATE = "BLACKLIST_ADD_OR_UPDATE"
local T_BLACKLIST_DELETED = "BLACKLIST_DELETED"
local T_BLACKLIST_SYNCED = "BLACKLIST_SYNCED"
local T_ON_BLACKLIST_STATE_UPDATE = "OnBlacklistStateUpdate"

-- Add them to the ns table so they can be referenced elsewhere
ns.T_BLACKLIST_STATE_REQUEST = T_BLACKLIST_STATE_REQUEST
ns.T_BLACKLIST_STATE = T_BLACKLIST_STATE
ns.T_BLACKLIST_ADD_OR_UPDATE = T_BLACKLIST_ADD_OR_UPDATE
ns.T_BLACKLIST_DELETED = T_BLACKLIST_DELETED
ns.T_BLACKLIST_SYNCED = T_BLACKLIST_SYNCED
ns.T_ON_BLACKLIST_STATE_UPDATE = T_ON_BLACKLIST_STATE_UPDATE

-- Pending transactions
local T_PENDING_TRANSACTION_STATE_REQUEST = "PENDING_TRANSACTION_STATE_REQUEST"
local T_PENDING_TRANSACTION_STATE = "PENDING_TRANSACTION_STATE"
local T_PENDING_TRANSACTION_ADD_OR_UPDATE = "PENDING_TRANSACTION_ADD_OR_UPDATE"
local T_PENDING_TRANSACTION_DELETED = "PENDING_TRANSACTION_DELETED"
local T_PENDING_TRANSACTION_SYNCED = "PENDING_TRANSACTION_SYNCED"

ns.T_PENDING_TRANSACTION_STATE_REQUEST = T_PENDING_TRANSACTION_STATE_REQUEST
ns.T_PENDING_TRANSACTION_STATE = T_PENDING_TRANSACTION_STATE
ns.T_PENDING_TRANSACTION_ADD_OR_UPDATE = T_PENDING_TRANSACTION_ADD_OR_UPDATE
ns.T_PENDING_TRANSACTION_DELETED = T_PENDING_TRANSACTION_DELETED
ns.T_PENDING_TRANSACTION_SYNCED = T_PENDING_TRANSACTION_SYNCED
ns.T_ON_PENDING_TRANSACTION_STATE_UPDATE = "OnPendingTransactionStateUpdate"

local T_AUCTION_ACK = "AUCTION_ACK"
local T_TRADE_ACK = "TRADE_ACK"
local T_RATING_ACK = "RATING_ACK"
local T_LFG_ACK = "LFG_ACK"
local T_BLACKLIST_ACK = "BLACKLIST_ACK"
local T_PENDING_TRANSACTION_ACK = "PENDING_TRANSACTION_ACK"

ns.T_AUCTION_ACK = T_AUCTION_ACK
ns.T_TRADE_ACK = T_TRADE_ACK
ns.T_RATING_ACK = T_RATING_ACK
ns.T_LFG_ACK = T_LFG_ACK
ns.T_BLACKLIST_ACK = T_BLACKLIST_ACK
ns.T_PENDING_TRANSACTION_ACK = T_PENDING_TRANSACTION_ACK

local knownAddonVersions = {}

local ADMIN_USERS = {
    --["Athenegpt-Soulseeker"] = 1,
    -- ["Maralle-Soulseeker"] = 1,
}

-- Constants
local TEST_USERS = {
    --["Lenkomag"] = "AtheneDev-lenkomag",
    --["Lenkomage"] = "AtheneDev-lenkomage"
    --  ["Pencilbow"] = "AtheneDev-pencilbow",
    -- ["Onefingerjoe"] = "AtheneDev-jannysice",
    --  ["Flawlezzgg"] = "AtheneDev-flawlezzgg",
    -- ["Pencilshaman"] = "AtheneDev-pencilshaman",
    -- ["Smorcstronk"] = "AtheneDev-smorcstronk",
}
ns.TEST_USERS = TEST_USERS
local TEST_USERS_RACE = {
    --["Lenkomag"] = "Troll",
    --["Lenkomage"] = "Naga"
    --  ["Pencilbow"] = "Human",
    -- ["Onefingerjoe"] = "Human",
    -- ["Flawlezzgg"] = "Human",
    -- ["Pencilshaman"] = "Undead",
    -- ["Smorcstronk"] = "Orc",
}

ns.COMM_PREFIX = COMM_PREFIX
ns.T_GUILD_ROSTER_CHANGED = "GUILD_ROSTER_CHANGED"

ns.T_CONFIG_REQUEST = T_CONFIG_REQUEST
ns.T_CONFIG_CHANGED = T_CONFIG_CHANGED
ns.T_AUCTION_ADD_OR_UPDATE = T_AUCTION_ADD_OR_UPDATE
ns.T_AUCTION_DELETED = T_AUCTION_DELETED
ns.T_AUCTION_STATE = T_AUCTION_STATE
ns.T_AUCTION_STATE_REQUEST = T_AUCTION_STATE_REQUEST
ns.T_AUCTION_SYNCED = T_AUCTION_SYNCED
ns.T_ON_AUCTION_STATE_UPDATE = "OnAuctionStateUpdate"

-- trades
ns.T_TRADE_ADD_OR_UPDATE = "TRADE_ADD_OR_UPDATE"
ns.T_TRADE_DELETED = "TRADE_DELETED"
ns.T_TRADE_SYNCED = "TRADE_SYNCED"

ns.T_ON_TRADE_STATE_UPDATE = "OnTradeStateUpdate"
ns.T_TRADE_STATE_REQUEST = "TRADE_REQUEST"
ns.T_TRADE_STATE = "TRADE_STATE"

-- trade ratings
ns.T_RATING_ADD_OR_UPDATE = T_RATING_ADD_OR_UPDATE
ns.T_RATING_DELETED = T_RATING_DELETED
ns.T_RATING_SYNCED = T_RATING_SYNCED

ns.T_ON_RATING_STATE_UPDATE = "OnRatingStateUpdate"
ns.T_RATING_STATE_REQUEST = "RATING_STATE_REQUEST"
ns.T_RATING_STATE = "RATING_STATE"

-- death clips
ns.T_DEATH_CLIPS_STATE_REQUEST = "DEATH_CLIPS_STATE_REQUEST"
ns.T_DEATH_CLIPS_STATE = "DEATH_CLIPS_STATE"
ns.T_ADMIN_REMOVE_CLIP = "ADMIN_REMOVE_CLIP"
ns.EV_DEATH_CLIPS_CHANGED = "DEATH_CLIPS_CHANGED"
--ns.T_ADMIN_UPDATE_CLIP_OVERRIDES = "ADMIN_UPDATE_CLIP_OVERRIDES"
ns.T_DEATH_CLIP_ADDED = "DEATH_CLIP_ADDED"

ns.T_DEATH_CLIP_REVIEW_STATE_REQUEST = "DEATH_CLIP_REVIEW_STATE_REQUEST"
ns.T_DEATH_CLIP_REVIEW_STATE = "DEATH_CLIP_REVIEW_STATE"
ns.T_DEATH_CLIP_REVIEW_UPDATED = "DEATH_CLIP_REVIEW_UPDATED"

-- version check
ns.T_ADDON_VERSION_REQUEST = "ADDON_VERSION_REQUEST"
ns.T_ADDON_VERSION_RESPONSE = "ADDON_VERSION_RESPONSE"

ns.T_SET_GUILD_POINTS = "SET_GUILD_POINTS"

local G, W = "GUILD", "WHISPER"

local CHANNEL_WHITELIST = {
    [ns.T_CONFIG_REQUEST] = { [G] = 1 },
    [ns.T_CONFIG_CHANGED] = { [W] = 1 },

    [ns.T_AUCTION_STATE_REQUEST] = { [G] = 1 },
    [ns.T_AUCTION_STATE] = { [W] = 1 },
    [ns.T_AUCTION_ADD_OR_UPDATE] = { [G] = 1 },
    [ns.T_AUCTION_DELETED] = { [G] = 1 },

    [ns.T_AUCTION_ACK] = { [G] = 1 },
    [ns.T_TRADE_ACK] = { [G] = 1 },
    [ns.T_RATING_ACK] = { [G] = 1 },
    [ns.T_LFG_ACK] = { [G] = 1 },
    [ns.T_BLACKLIST_ACK] = { [G] = 1 },
    [ns.T_PENDING_TRANSACTION_ACK] = { [G] = 1 },

    [ns.T_TRADE_STATE_REQUEST] = { [G] = 1 },
    [ns.T_TRADE_STATE] = { [W] = 1 },
    [ns.T_TRADE_ADD_OR_UPDATE] = { [G] = 1 },
    [ns.T_TRADE_DELETED] = { [G] = 1 },

    [ns.T_RATING_STATE_REQUEST] = { [G] = 1 },
    [ns.T_RATING_STATE] = { [W] = 1 },
    [ns.T_RATING_ADD_OR_UPDATE] = { [G] = 1 },
    [ns.T_RATING_DELETED] = { [G] = 1 },

    [ns.T_DEATH_CLIPS_STATE_REQUEST] = { [G] = 1 },
    [ns.T_DEATH_CLIPS_STATE] = { [W] = 1 },
    [ns.T_ADMIN_REMOVE_CLIP] = {}, --admin only
    [ns.T_DEATH_CLIP_REVIEW_STATE_REQUEST] = { [G] = 1 },
    [ns.T_DEATH_CLIP_REVIEW_STATE] = { [W] = 1 },
    [ns.T_DEATH_CLIP_REVIEW_UPDATED] = { [G] = 1 },
    --[ns.T_ADMIN_UPDATE_CLIP_OVERRIDES] = {}, --admin only
    [ns.T_DEATH_CLIP_ADDED] = { [G] = 1 },


    [ns.T_ADDON_VERSION_REQUEST] = { [G] = 1 },
    [ns.T_ADDON_VERSION_RESPONSE] = { [W] = 1 },

    -- LFG
    [ns.T_LFG_STATE_REQUEST] = { [G] = 1 },
    [ns.T_LFG_STATE] = { [W] = 1 },
    [ns.T_LFG_ADD_OR_UPDATE] = { [G] = 1 },
    [ns.T_LFG_DELETED] = { [G] = 1 },

    -- Blacklist
    [ns.T_BLACKLIST_STATE_REQUEST] = { [G] = 1 },
    [ns.T_BLACKLIST_STATE] = { [W] = 1 },
    [ns.T_BLACKLIST_ADD_OR_UPDATE] = { [G] = 1 },
    [ns.T_BLACKLIST_DELETED] = { [G] = 1 },

    [ns.T_SET_GUILD_POINTS] = { [W] = 1 },

    -- Pending transaction
    [ns.T_PENDING_TRANSACTION_DELETED] = { [G] = 1 },
    [ns.T_PENDING_TRANSACTION_ADD_OR_UPDATE] = { [G] = 1 },
    [ns.T_PENDING_TRANSACTION_STATE_REQUEST] = { [G] = 1 },
    [ns.T_PENDING_TRANSACTION_STATE] = { [W] = 1 },
}

-- make isMessageAllowed use name-only
local function getFullName(unitName)
    return unitName   -- since UnitName("player") is just the name
end

local function isMessageAllowed(sender, channel, messageType)
    local fullName = getFullName(sender)
    if ADMIN_USERS[fullName] then
        return true
    end
    if not CHANNEL_WHITELIST[messageType] then
        return false
    end
    if not CHANNEL_WHITELIST[messageType][channel] then
        return false
    end
    return true
end

local AuctionHouse = {}
AuctionHouse.__index = AuctionHouse

function AuctionHouse.new()
    local instance = setmetatable({}, AuctionHouse)

    -- Initialize ack tables
    instance.lastAckAuctionRevisions = {}
    instance.lastAckTradeRevisions = {}
    instance.lastAckRatingRevisions = {}
    instance.lastAckLFGRevisions = {}
    instance.lastAckBlacklistRevisions = {}
    instance.lastAckPendingTransactionRevisions = {}

    -- Initialize ack broadcast flags for various state types
    instance.ackBroadcasted = false
    instance.tradeAckBroadcasted = false
    instance.ratingAckBroadcasted = false
    instance.lfgAckBroadcasted = false
    instance.blacklistAckBroadcasted = false
    instance.pendingTransactionAckBroadcasted = false

    -- Hooks for testing; by default they do nothing.
    instance.OnStateRequestHandled = function(self, sender, payload)
    end
    instance.OnStateResponseHandled = function(self, sender, payload)
    end

    return instance
end

function AuctionHouse:SetupTestUsers()
    local realmName = GetRealmName()
    realmName = realmName:gsub("%s+", "")

    if _G.OnlyFangsStreamerMap then
        for name, value in pairs(TEST_USERS) do
            _G.OnlyFangsStreamerMap[name .. "-" .. realmName] = value
        end
    end
    if _G.OnlyFangsRaceMap then
        for name, value in pairs(TEST_USERS_RACE) do
            _G.OnlyFangsRaceMap[name .. "-" .. realmName] = value
        end
    end

    if _G.SixtyProject and _G.SixtyProject.dbGlobal and _G.SixtyProject.dbGlobal.Guild then
        for name, twitchName in pairs(TEST_USERS) do
            local guildEntry = _G.SixtyProject.dbGlobal.Guild[name] or {}
            guildEntry.Streamer = twitchName
            guildEntry.Race = TEST_USERS_RACE[name] or "Human"
            guildEntry.Class = "Warrior"  -- Default dummy value
            guildEntry.Level = 60         -- Max level
            guildEntry.Gender = 2         -- 2 typically represents female
            guildEntry.Honor = 0          -- Starting honor
            guildEntry.Alive = true       -- Default to alive
            guildEntry.Points = 0         -- Starting points
            guildEntry.LastSync = time()
            _G.SixtyProject.dbGlobal.Guild[name] = guildEntry
        end
    end
end

function AuctionHouse:Initialize()
    self.playerName = UnitName("player")
    self.addonVersion = GetAddOnMetadata(addonName, "Version")
    knownAddonVersions[self.addonVersion] = true

    ChatUtils_Initialize()

    -- Initialize API
    ns.AuctionHouseAPI:Initialize({
        -- AUCTIONS ---------------------------------------------------------------
        broadcastAuctionUpdate = function(dataType, payload)
            -- Only ship auctions from my realm
            if payload.auction and payload.auction.realm == ns.CURRENT_REALM then
                self:BroadcastAuctionUpdate(dataType, payload)
            end
        end,

        -- TRADES -----------------------------------------------------------------
        broadcastTradeUpdate = function(dataType, payload)
            -- Trades inherit the auction’s realm when they are created
            if payload.trade and payload.trade.realm == ns.CURRENT_REALM then
                self:BroadcastTradeUpdate(dataType, payload)
            end
        end,

        -- RATINGS ---------------------------------------------------------------
        broadcastRatingUpdate = function(dataType, payload)
            -- Ratings reference a trade → same realm flag
            if payload.rating and payload.rating.realm == ns.CURRENT_REALM then
                self:BroadcastRatingUpdate(dataType, payload)
            end
        end,

        -- LFG POSTS --------------------------------------------------------------
        broadcastLFGUpdate = function(dataType, payload)
            -- LFG posts are always realm-scoped by design, keep the symmetry
            if payload.lfg and payload.lfg.realm == ns.CURRENT_REALM then
                self:BroadcastLFGUpdate(dataType, payload)
            end
        end,

        -- BLACKLIST --------------------------------------------------------------
        broadcastBlacklistUpdate = function(dataType, payload)
            -- Blacklist entries carry the offending player’s realm
            if payload.entry and payload.realm == ns.CURRENT_REALM then
                self:BroadcastBlacklistUpdate(dataType, payload)
            end
        end,

        -- PENDING TRANSACTIONS ---------------------------------------------------
        broadcastPendingTransactionUpdate = function(dataType, payload)
            -- Same guard for buy/sell confirmation messages
            if payload.transaction and payload.transaction.realm == ns.CURRENT_REALM then
                self:BroadcastPendingTransactionUpdate(dataType, payload)
            end
        end,
    })

    ns.AuctionHouseAPI:Load()
    self.db = ns.AuctionHouseDB

    -- If needed for test users, show debug UI on load
    if ns.AuctionHouseDB.revision == 0 and TEST_USERS[UnitName("player")] then
        ns.AuctionHouseDB.showDebugUIOnLoad = true
    end

    local clipReviewState = ns.GetDeathClipReviewState()
    clipReviewState:RegisterEvent(ns.EV_DEATH_CLIP_REVIEW_ADD_OR_UPDATE, function(payload)
        if payload.fromNetwork then
            return
        end
        --print("SENDING REVIEW", payload.review and payload.review.id)
        self:BroadcastMessage(Addon:Serialize({ ns.T_DEATH_CLIP_REVIEW_UPDATED, { review = payload.review } }))
    end)
    --clipReviewState:RegisterEvent(ns.EV_DEATH_CLIP_OVERRIDE_UPDATED, function(payload)
    --    if payload.fromNetwork then
    --        return
    --    end
    --    self:BroadcastMessage(Addon:Serialize({ ns.T_ADMIN_UPDATE_CLIP_OVERRIDES, { clipID = payload.clipID, overrides = payload.overrides } }))
    --end)

    -- Initialize UI
    ns.TradeAPI:OnInitialize()
    ns.MailboxUI:Initialize()
    ns.AuctionAlertWidget:OnInitialize()
    OFAuctionFrameReviews_Initialize()
    LfgUI_Initialize()
    SettingsUI_Initialize()
    OFAtheneUI_Initialize()

    local age = time() - ns.AuctionHouseDB.lastUpdateAt
    local auctions = ns.AuctionHouseDB.auctions
    local auctionCount = 0
    for _ in pairs(ns.FilterAuctionsThisRealm(auctions)) do
        auctionCount = auctionCount + 1
    end
    ns.DebugLog(string.format("[DEBUG] db loaded from persistence. rev: %s, lastUpdateAt: %d (%ds old) with %d auctions",
            ns.AuctionHouseDB.revision, ns.AuctionHouseDB.lastUpdateAt, age, auctionCount))

    AHConfigSaved = ns.GetConfig()

    -- Register comm prefixes
    Addon:RegisterComm(COMM_PREFIX)
    Addon:RegisterComm(OF_COMM_PREFIX)

    -- chat commands
    SLASH_GAH1 = "/gah"
    SlashCmdList["GAH"] = function(msg)
        self:OpenAuctionHouse()
    end

    -- Start auction expiration and trade trimming
    C_Timer:NewTicker(10, function()
        API:ExpireAuctions()
    end)
    C_Timer:NewTicker(61, function()
        API:TrimTrades()
    end)

    -- Add TEST_USERS to OnlyFangsStreamerMap for debugging. eg the mail don't get auto returned
    -- run periodically because these maps get rebuilt regularly when the guild roster updates
    if TEST_USERS[UnitName("player")] then
        -- Run setup immediately
        self:SetupTestUsers()

        C_Timer:NewTicker(1, function()
            self:SetupTestUsers()
        end)
    end

    self.initAt = time()
    self:RequestLatestConfig()
    self:RequestLatestState()
    self:RequestLatestTradeState()
    self:RequestLatestRatingsState()
    self:RequestLatestDeathClipState(self.initAt)
    self:RequestLatestLFGState()
    self:RequestLatestBlacklistState()
    self:RequestAddonVersion()
    self:RequestDeathClipReviewState()
    self:RequestLatestPendingTransactionState()

    if self.db.showDebugUIOnLoad and self.CreateDebugUI then
        self:CreateDebugUI()
        self.debugUI:Show()
    end
    if self.db.openAHOnLoad then
        -- needs a delay to work properly, for whatever reason
        C_Timer:NewTimer(0.5, function()
            OFAuctionFrame_OverrideInitialTab(ns.AUCTION_TAB_BROWSE)
            OFAuctionFrame:Show()
        end)
    end

    self.ignoreSenderCheck = false
end

function AuctionHouse:BroadcastMessage(message)
    local channel = "GUILD"
    Addon:SendCommMessage(COMM_PREFIX, message, channel)
    return true
end

function AuctionHouse:SendDm(message, recipient, prio)
    -- FIXME TODO 3.3.5 HC guys must have weird names right???
    Addon:SendCommMessage(COMM_PREFIX, message, "WHISPER", recipient, prio)
end

function AuctionHouse:BroadcastAuctionUpdate(dataType, payload)
    self:BroadcastMessage(Addon:Serialize({ dataType, payload }))
end

function AuctionHouse:BroadcastTradeUpdate(dataType, payload)
    self:BroadcastMessage(Addon:Serialize({ dataType, payload }))
end

function AuctionHouse:BroadcastRatingUpdate(dataType, payload)
    self:BroadcastMessage(Addon:Serialize({ dataType, payload }))
end

function AuctionHouse:BroadcastLFGUpdate(dataType, payload)
    self:BroadcastMessage(Addon:Serialize({ dataType, payload }))
end

function AuctionHouse:BroadcastBlacklistUpdate(dataType, payload)
    self:BroadcastMessage(Addon:Serialize({ dataType, payload }))
end

function AuctionHouse:BroadcastPendingTransactionUpdate(dataType, payload)
    self:BroadcastMessage(Addon:Serialize({ dataType, payload }))
end

function AuctionHouse:BroadcastDeathClipAdded(clip)
    self:BroadcastMessage(Addon:Serialize({ ns.T_DEATH_CLIP_ADDED, clip }))
end

function AuctionHouse:IsSyncWindowExpired()
    -- safety: only allow initial state within 2 minutes after login (chat can be very slow due to ratelimit, so has to be high)
    -- just in case there's a bug we didn't anticipate
    return GetTime() - self.initAt > 120
end

-- Helper: a random delay biased toward the higher end.
local function randomBiasedDelay(min, max)
    -- Using an exponent to skew the result toward 'max'
    return min + (max - min) * (math.random() ^ (1 / 3))
end

ns.RandomBiasedDelay = randomBiasedDelay

-- Helper: converts a string into a numeric seed.
local function stringToSeed(s)
    local seed = 0
    for i = 1, #s do
        seed = seed + s:byte(i) * i
    end
    return seed
end

-- Helper: performs a Fisher–Yates shuffle using a simple linear congruential generator.
local function seededShuffle(t, seed)
    local m = 2147483647  -- a large prime for modulus
    local a = 16807       -- common multiplier for LCG
    local localSeed = seed
    for i = #t, 2, -1 do
        localSeed = (localSeed * a) % m
        local j = (localSeed % i) + 1
        t[i], t[j] = t[j], t[i]
    end
end

-- Helper: decide if we are a primary responder based on a deterministic shuffle of the guild roster.
function AuctionHouse:IsPrimaryResponder(playerName, dataType, sender)
    local myName = getFullName(playerName)
    local guildMembers = {}
    local senderFullName = getFullName(sender)

    table.insert(guildMembers, myName)

    -- Use DB.blacklists as source of names, but filter for online guild members
    if ns.GuildRegister.table then
        for name, _ in pairs(self.db.blacklists or {}) do
            -- Check if this player is in the guild and online, and is not the sender
            if ns.GuildRegister.table[name] and
                    ns.GuildRegister.table[name].isOnline and
                    name ~= senderFullName and
                    name ~= myName then
                table.insert(guildMembers, name)
            end
        end
    end
    table.sort(guildMembers)

    -- Derive a seed from the sender so that the shuffle is deterministic
    local seed = stringToSeed(dataType .. "#" .. sender)
    seededShuffle(guildMembers, seed)

    local myRank = nil
    for i, name in ipairs(guildMembers) do
        if name == myName then
            myRank = i
            break
        end
    end

    -- Top 2 in the shuffled order are the primary responders
    return (myRank ~= nil and myRank <= 2)
end

-- wrapper function for overridding during tests
function AuctionHouse:After(delay, callback)
    C_Timer:After(delay, callback)
end

function Addon:OnCommReceived(prefix, message, distribution, sender)
    --print(message .. sender)
    ns.AuctionHouse:OnCommReceived(prefix, message, distribution, sender)
end

function AuctionHouse:HandleStateUpdate(sender, dataType, cfg, sendPayloadFn)
    local dbRev = cfg.rev
    if dbRev <= cfg.payloadRev then
        ns.DebugLog("[DEBUG] Ignoring", dataType, ". local rev:", dbRev, "requester rev:", cfg.payloadRev)
        return
    end
    cfg.setLastAck(sender, nil)

    local function sendUpdate()
        local ackRev = cfg.getLastAck(sender)
        if ackRev and ackRev >= dbRev then
            ns.DebugLog("[DEBUG] Delayed " .. dataType .. " update cancelled due to ACK received")
            return
        end

        sendPayloadFn()
        ns.DebugLog(string.format("[DEBUG] Sent %s: rev %d, requester rev %d, ack %s",
                dataType, dbRev, cfg.payloadRev, tostring(ackRev or -1)))
    end

    if self:IsPrimaryResponder(self.playerName, dataType, sender) then
        ns.DebugLog("[DEBUG] Immediate " .. dataType .. " state update (primary responder)")
        sendUpdate()
    else
        local delay = randomBiasedDelay(5, 15)
        ns.DebugLog("[DEBUG] Scheduling delayed " .. dataType .. " state update in " .. math.floor(delay) .. "s")
        self:After(delay, sendUpdate)
    end
end

function AuctionHouse:HandleAck(dataType, sender, payload, ackTable)
    local lastAckRev = ackTable[sender]

    ns.DebugLog(string.format("[DEBUG] Received %s ACK from %s with revision: %d local:%d",
            dataType,
            sender,
            payload.revision,
            (lastAckRev or -1)
    ))

    if not lastAckRev or lastAckRev < payload.revision then
        ackTable[sender] = payload.revision
    end
end

function AuctionHouse:BroadcastAck(ackType, revision, isHigherRevision, broadcastFlag)
    if not self[broadcastFlag] or isHigherRevision then
        ns.DebugLog("[DEBUG] Broadcasting " .. ackType .. " ACK with revision: " .. tostring(revision))
        self:BroadcastMessage(Addon:Serialize({ ackType, { revision = revision } }))
        self[broadcastFlag] = true
    end
end

function AuctionHouse:OnCommReceived(prefix, message, distribution, sender)
    --print(message..sender)
    -- disallow whisper messages from outside the guild to avoid bad actors to inject malicious data
    -- this means that early on during login we might discard messages from guild members until the guild roaster is known.
    -- however, since we sync the state with the guild roaster on login this shouldn't be a problem.
    if not self.ignoreSenderCheck and distribution == "GUILD" and not ns.IsGuildMember(sender) then
        return
    end

    -- handle OF-specific prefix first
    if prefix == OF_COMM_PREFIX then
        ns.HandleOFCommMessage(message, sender, distribution)
        return
    end

    -- only handle our addon’s COMM_PREFIX from here
    if prefix ~= COMM_PREFIX then
        return
    end
    if sender == UnitName("player") and not self.ignoreSenderCheck then
        return
    end

    -- ==== DESERIALIZE: either compressed “DF:” payload or raw ====
    local dataType, payload

    if message:sub(1, 3) == "DF:" then
        local deflated = message:sub(4)

        -- decode Base64 → compressed bytes
        local compressed = LibDeflate:DecodeForWoWAddonChannel(deflated)
        if type(compressed) ~= "string" then
            ChatFrame1:AddMessage("!DBG: DecodeForWoWAddonChannel failed")
            return
        end

        -- decompress → serialized JSON string
        local serialized = LibDeflate:DecompressDeflate(compressed)
        if type(serialized) ~= "string" then
            ChatFrame1:AddMessage("!DBG: DecompressDeflate failed")
            return
        end

        -- deserialize → Lua table { dataType, payload }
        local ok, tbl = Addon:Deserialize(serialized)
        if not ok then
            ChatFrame1:AddMessage("!DBG: Deserialize failed")
            return
        end

        dataType = tbl[1]
        payload = tbl[2]

    else
        -- legacy, raw path for everything else
        local ok, tbl = Addon:Deserialize(message)
        if not ok then
            ChatFrame1:AddMessage("!DBG: Deserialize(raw) failed")
            return
        end
        dataType = tbl[1]
        payload = tbl[2]
    end

    ns.DebugLog("[DEBUG]", self.playerName, "recv", dataType, sender)
    if not isMessageAllowed(sender, distribution, dataType) then
        ns.DebugLog("[DEBUG] Ignoring message from", sender, "of type", dataType, "in channel", distribution)
        return
    end

    -- Auction
    if dataType == T_AUCTION_ADD_OR_UPDATE then
        API:UpdateDB(payload)
        API:FireEvent(ns.T_AUCTION_ADD_OR_UPDATE, { auction = payload.auction, source = payload.source })

    elseif dataType == T_AUCTION_DELETED then
        API:DeleteAuctionInternal(payload, true)
        API:FireEvent(ns.T_AUCTION_DELETED, payload)

        -- Trades
    elseif dataType == ns.T_TRADE_ADD_OR_UPDATE then
        API:UpdateDBTrade({ trade = payload.trade })
        API:FireEvent(ns.T_TRADE_ADD_OR_UPDATE, { auction = payload.auction, source = payload.source })

    elseif dataType == ns.T_TRADE_DELETED then
        API:DeleteTradeInternal(payload, true)

        -- Ratings
    elseif dataType == ns.T_RATING_ADD_OR_UPDATE then
        API:UpdateDBRating(payload)
        API:FireEvent(ns.T_RATING_ADD_OR_UPDATE, { rating = payload.rating, source = payload.source })

    elseif dataType == ns.T_RATING_DELETED then
        API:DeleteRatingInternal(payload, true)
        API:FireEvent(ns.T_RATING_DELETED, { ratingID = payload.ratingID })

        -- LFG
    elseif dataType == ns.T_LFG_ADD_OR_UPDATE then
        ns.LfgAPI:UpdateDBLFG(payload)
        API:FireEvent(ns.T_LFG_ADD_OR_UPDATE, { lfg = payload.lfg, source = payload.source })

    elseif dataType == ns.T_LFG_DELETED then
        local success, err = ns.LfgAPI:DeleteEntry(payload, true, true)
        if not success then
            ns.DebugLog("Failed to delete LFG entry:", payload, err)
        end
        API:FireEvent(ns.T_LFG_DELETED, { lfgKey = payload })

    elseif dataType == ns.T_PENDING_TRANSACTION_ADD_OR_UPDATE then
        -- Update the pending transaction in the DB and fire event
        ns.PendingTxAPI:UpdateDBPendingTransaction(payload)
        API:FireEvent(ns.T_PENDING_TRANSACTION_ADD_OR_UPDATE, { pendingTransaction = payload.transaction, source = payload.source })

        -- Handle the transaction
        ns.PendingTxAPI:HandlePendingTransactionChange(payload.transaction)

    elseif dataType == ns.T_PENDING_TRANSACTION_DELETED then
        -- Delete the pending transaction and fire event
        local success, err = ns.PendingTxAPI:RemovePendingTransaction(payload, true)
        if not success then
            ns.DebugLog("Failed to delete Pending Tx:", payload, err)
        end

    elseif dataType == T_AUCTION_STATE_REQUEST then
        self:HandleStateUpdate(sender, T_AUCTION_STATE_REQUEST, {
            rev = self.db.revision,
            payloadRev = payload.revision,
            getLastAck = function(sender)
                return self.lastAckAuctionRevisions[sender]
            end,
            setLastAck = function(sender, value)
                self.lastAckAuctionRevisions[sender] = value
            end
        }, function()
            local responsePayload, _, __ = self:BuildDeltaState(payload.revision, payload.auctions)
            local compressed = LibDeflate:CompressDeflate(Addon:Serialize(responsePayload))

            self:SendDm(Addon:Serialize({ T_AUCTION_STATE, compressed }), sender, "BULK")
        end)

    elseif dataType == T_AUCTION_STATE then
        local decompressStart = GetTimePreciseSec()
        local decompressed = LibDeflate:DecompressDeflate(payload)
        local decompressTime = (GetTimePreciseSec() - decompressStart) * 1000

        local deserializeStart = GetTimePreciseSec()
        local success, state = Addon:Deserialize(decompressed)
        local deserializeTime = (GetTimePreciseSec() - deserializeStart) * 1000

        if not success then
            return
        end

        -- Update revision and lastUpdateAt if necessary
        local isHigherRevision = state.revision > self.db.revision
        if isHigherRevision then
            -- Update local auctions with received data
            for id, auction in pairs(state.auctions or {}) do
                local oldAuction = self.db.auctions[id]
                self.db.auctions[id] = auction

                -- Fire event only if auction changed, with appropriate source
                if not oldAuction then
                    -- New auction
                    API:FireEvent(ns.T_AUCTION_SYNCED, { auction = auction, source = "create" })

                elseif oldAuction.rev == auction.rev then
                    -- no events to fire

                elseif oldAuction.status ~= auction.status then
                    -- status change event
                    local source = "status_update"
                    if auction.status == ns.AUCTION_STATUS_PENDING_TRADE then
                        source = "buy"
                    elseif auction.status == ns.AUCTION_STATUS_PENDING_LOAN then
                        source = "buy_loan"
                    end

                    API:FireEvent(ns.T_AUCTION_SYNCED, { auction = auction, source = source })
                else
                    -- unknown update reason (source)
                    API:FireEvent(ns.T_AUCTION_SYNCED, { auction = auction })
                end
            end

            -- Delete auctions that are no longer valid
            for _, id in ipairs(state.deletedAuctionIds or {}) do
                self.db.auctions[id] = nil
            end

            self.db.revision = state.revision
            self.db.lastUpdateAt = state.lastUpdateAt

            API:FireEvent(ns.T_ON_AUCTION_STATE_UPDATE)

            ns.DebugLog(string.format("[DEBUG] Updated local state with %d new auctions, %d deleted auctions, revision %d (bytes-compressed: %d, decompress: %.0fms, deserialize: %.0fms)",
                    #(state.auctions or {}), #(state.deletedAuctionIds or {}),
                    self.db.revision,
                    #payload,
                    decompressTime, deserializeTime
            ))
        end

        -- Broadcast an ACK on the guild channel
        self:BroadcastAck(ns.T_AUCTION_ACK, self.db.revision, isHigherRevision, "ackBroadcasted")

        -- Added hook call so that (for example) tests can capture state response data:
        if self.OnStateResponseHandled then
            self:OnStateResponseHandled(sender, state)
        end

    elseif dataType == T_CONFIG_REQUEST then
        if AHConfigSaved and payload.version < AHConfigSaved.version then
            self:SendDm(Addon:Serialize({ T_CONFIG_CHANGED, AHConfigSaved }), sender, "BULK")
        end


        -- === Sender: T_DEATH_CLIPS_STATE_REQUEST ===
    elseif dataType == ns.T_DEATH_CLIPS_STATE_REQUEST then

        local since = payload.since
        local clips = payload.clips or {}
        print(("🔍DBG: Payload since TS = %s, have %d clip-IDs"):format(
                tostring(since), #clips
        ))

        local rawClips = ns.GetNewDeathClips(since, clips)
        print((">> DEBUG: %d death-clips to sync"):format(#rawClips))
        if #rawClips == 0 then
            return
        end

        -- sort by ts
        table.sort(rawClips, function(a, b)
            return (a.ts or 0) < (b.ts or 0)
        end)

        -- precompute our realm
        local fullRealm = GetRealmName() or ""
        local realmID = ns.RealmFullNameToID[fullRealm] or 0

        local rows = {}
        for i, c in ipairs(rawClips) do
            local ts = c.ts or 0  -- absolute server time

            -- strip color from mob name
            local mobName = (c.deathCause or "")
                    :gsub("|c%x%x%x%x%x%x%x%x", "")
                    :gsub("|r", "")

            -- determine causeCode (0–10, default 7)
            local causeCode = 7
            for id, text in pairs(ns.DeathCauseByID) do
                if id ~= 7 and c.deathCause:find(text, 1, true) then
                    causeCode = id
                    break
                end
            end
            local mobData
            if causeCode == 7 and mobName ~= "" then
                mobData = ns.MobIDByName[mobName] or mobName -- Assign ID if found, otherwise fallback to mobName string
            else
                mobData = "" -- Assign empty string if not causeCode 7 or mobName is empty
            end

            -- zone → ID + fallback string
            local zid = ns.ZoneIDByName[c.where] or 0
            local rawZone = (zid > 0) and nil or (c.where or "")

            -- faction → code
            local facCode = (c.faction == "Alliance" and 1)
                    or (c.faction == "Horde" and 2)
                    or 3

            -- race & class codes
            local raceCode = ns.RaceIDByName[c.race] or 0
            local classCode = ns.ClassIDByName[c.class] or 0

            -- **NEW**: read the raw mobLevel field directly
            local mobLevelNum = c.mobLevel or 0

            -- build the row
            local row = {
                c.characterName or "", -- [1]
                ts, -- [2]
                classCode, -- [3]
                c.completed and 0 or causeCode, -- [4]
                raceCode, -- [5]
                c.completed and 0 or zid, -- [6]
                facCode, -- [7]
                realmID, -- [8]
                c.level or 0, -- [9]
                c.getPlayedTry or 0, -- [10]
                tonumber(c.playedTime) or nil, -- [11]
                (not c.completed) and mobData or "", -- [12] NEW (mobData can be ID or string)
            }

            row[13] = mobLevelNum              -- [13] fixed mob level
            row[14] = c.completed or nil       -- [14] completed flag

            -- optional zone + realm strings
            local idx = 15
            if (not c.completed) and row[6] == 0 and rawZone then
                row[idx] = rawZone
                idx = idx + 1
            end
            if (not c.completed) and row[8] == 0 and fullRealm then
                row[idx] = fullRealm
            end

            rows[i] = row
        end

        -- ------------------------------------------------------------------
        -- Debug: pretty-print one RAW 'rows' entry (numeric array)
        -- ------------------------------------------------------------------
        local function DebugDumpClipArr(arr)
            -- map numeric slots -> human labels so the printout is readable
            local labels = {
                "name", -- 1
                "ts", -- 2
                "classID", -- 3
                "causeID", -- 4
                "raceID", -- 5
                "zoneID", -- 6
                "factionID", -- 7
                "realmID", -- 8
                "level", -- 9
                "getPlayedTry", --10
                "playedTime", --11
                "mobName", --12
                "mobLevel", --13
                "realmName", --14
                "zoneName", --15 (optional fallback)
                "completed", --16
            }

            local parts = {}
            for i = 1, #arr do
                table.insert(parts, labels[i] .. "=" .. tostring(arr[i]))
            end
            --print("SEND-RAW {" .. table.concat(parts, ", ") .. "}")
        end

        local debugShown = 0                         -- NEW

        for _, arr in ipairs(rows) do
            if debugShown < 100 then
                -- print only first 100
                DebugDumpClipArr(arr)
                debugShown = debugShown + 1
            end
        end


        -- serialize & send
        local serialized = Addon:Serialize(rows)
        print((">> DEBUG: serialized rows = %d bytes"):format(#serialized))
        local compressionConfigs = {level = 9}
        local compressed = LibDeflate:CompressDeflate(serialized, compressionConfigs)
        print((">> DEBUG: compressed rows = %d bytes (Level 9)"):format(#compressed))

        local msg = Addon:Serialize({ ns.T_DEATH_CLIPS_STATE, compressed })
        self:SendDm(msg, sender, "BULK")


        -- === Receiver: T_DEATH_CLIPS_STATE ===
    elseif dataType == ns.T_DEATH_CLIPS_STATE then

        local decompressed = LibDeflate:DecompressDeflate(payload)
        local ok, rows = Addon:Deserialize(decompressed)
        if not ok then
            return
        end

        for _, arr in ipairs(rows) do
            ----------------------------------------------------------------
            -- 1) pull in the raw ts
            ----------------------------------------------------------------
            local clipTS = arr[2] or 0
            local now = GetServerTime()
            if clipTS > now then
                clipTS = now
            end

            ----------------------------------------------------------------
            -- 2) look-ups and fallbacks
            ----------------------------------------------------------------
            local zid = arr[6] or 0
            local zoneName = (zid > 0 and ns.GetZoneNameByID(zid))
                    or arr[15] or ""

            local rid = arr[8] or 0
            local realmStr = (rid > 0 and ns.GetRealmNameByID(rid))
                    or ((zid == 0 and arr[16]) or arr[15])
                    or "UnknownRealm"

            local clipCompleted = arr[14] ~= nil            -- slot-14 flag
            local causeID = arr[4] or 0
            local mobPayload = arr[12] or "" -- This is the mobData from sender
            local mobNameForCause = ""
            if type(mobPayload) == "number" then -- It's an ID
                mobNameForCause = ns.MobNameByID[mobPayload] or "Неизвестный моб"
            elseif type(mobPayload) == "string" then -- It's a fallback string name
                mobNameForCause = mobPayload
            end

            local causeStr = clipCompleted and ""
                    or ns.GetDeathCauseByID(causeID, mobNameForCause) -- Use reconstructed/fallback name

            ----------------------------------------------------------------
            -- 3) class & race names
            ----------------------------------------------------------------
            local classStr = ns.ClassNameByID[arr[3]] or ""
            local raceInfo = ns.GetRaceInfoByID(arr[5])

            ----------------------------------------------------------------
            -- 4) rebuild the clip table
            ----------------------------------------------------------------
            local clip = {
                characterName = arr[1] or "",
                ts            = clipTS,
                classCode     = arr[3],
                class         = classStr,
                causeCode     = causeID,
                deathCause    = causeStr,
                raceCode      = arr[5],
                race          = raceInfo.name,
                where         = clipCompleted and "" or zoneName,
                factionCode   = arr[7],
                realmCode     = rid,
                realm         = realmStr,
                level         = arr[9],
                getPlayedTry  = arr[10],
                playedTime    = arr[11],
                mobLevel      = (arr[13] and arr[13] > 0) and arr[13] or nil,
                completed     = clipCompleted and true or nil,
            }

            ----------------------------------------------------------------
            -- 5) faction string
            ----------------------------------------------------------------
            if clip.factionCode == 1 then
                clip.faction = "Alliance"
            elseif clip.factionCode == 2 then
                clip.faction = "Horde"
            else
                clip.faction = "Neutral"
            end

            ----------------------------------------------------------------
            -- 6) ✂️ Minimal cleanup: drop unused or default fields
            ----------------------------------------------------------------
            clip.classCode, clip.raceCode, clip.factionCode, clip.realmCode = nil, nil, nil, nil
            if clip.playedTime then
                clip.getPlayedTry = nil
            end

            ----------------------------------------------------------------
            -- 7) build unique ID via helper
            ----------------------------------------------------------------
            clip.id = ns.GenerateClipID(clip, clip.completed)

            LiveDeathClips[clip.id] = clip
        end


        ------------------------------------------------------------------
        --  STOP BENCHMARK (debug only)
        ------------------------------------------------------------------
        -- ── POP & PRINT ──
        local entry = table.remove(self.benchDebugQueue or {}, 1)
        if entry then
            local elapsed = GetTime() - entry.start
            print(("|cff00ff00>> Bench[%d]: DeathClip sync completed at %s (took %.2f s)|r")
                    :format(entry.id, date("%H:%M"), elapsed))
        end

        API:FireEvent(ns.EV_DEATH_CLIPS_CHANGED)


    elseif dataType == ns.T_DEATH_CLIP_REVIEW_STATE_REQUEST then
        local rev = payload.rev
        local state = ns.GetDeathClipReviewState()
        if state.persisted.rev > rev then
            local responsePayload = state:GetSyncedState()
            local compressed = LibDeflate:CompressDeflate(Addon:Serialize(responsePayload))
            self:SendDm(Addon:Serialize({ ns.T_DEATH_CLIP_REVIEW_STATE, compressed }), sender, "BULK")
        end
    elseif dataType == ns.T_DEATH_CLIP_REVIEW_STATE then
        local decompressed = LibDeflate:DecompressDeflate(payload)
        local success, state = Addon:Deserialize(decompressed)
        if success then
            local reviewState = ns.GetDeathClipReviewState()
            reviewState:SyncState(state)
        end
    elseif dataType == ns.T_DEATH_CLIP_REVIEW_UPDATED then
        local review = payload.review
        local reviewState = ns.GetDeathClipReviewState()
        reviewState:UpdateReviewFromNetwork(review)
    --elseif dataType == ns.T_ADMIN_UPDATE_CLIP_OVERRIDES then
    --    local reviewState = ns.GetDeathClipReviewState()
    --    reviewState:UpdateClipOverrides(payload.clipID, payload.overrides, true)
    elseif dataType == ns.T_ADMIN_REMOVE_CLIP then
        ns.RemoveDeathClip(payload.clipID)
    elseif dataType == ns.T_DEATH_CLIP_ADDED then
        ns.AddNewDeathClips({ payload })
        local magicLink = ns.CreateMagicLink(ns.SPELL_ID_DEATH_CLIPS, L["watch death clip"])
        print(string.format(L["%s has died at Lv. %d."], ns.GetDisplayName(payload.characterName), payload.level) .. " " .. magicLink)
    elseif dataType == T_CONFIG_CHANGED then
        if payload.version > AHConfigSaved.version then
            AHConfigSaved = payload
        end

    elseif dataType == ns.T_TRADE_STATE_REQUEST then
        self:HandleStateUpdate(sender, ns.T_TRADE_STATE_REQUEST, {
            rev = self.db.revTrades or 0,
            payloadRev = payload.revTrades,
            getLastAck = function(sender)
                return self.lastAckTradeRevisions[sender]
            end,
            setLastAck = function(sender, value)
                self.lastAckTradeRevisions[sender] = value
            end
        }, function()
            local responsePayload, tradeCount, deletedCount = self:BuildTradeDeltaState(payload.revision, payload.trades)
            local compressed = LibDeflate:CompressDeflate(Addon:Serialize(responsePayload))
            self:SendDm(Addon:Serialize({ ns.T_TRADE_STATE, compressed }), sender, "BULK")
        end)

    elseif dataType == ns.T_TRADE_STATE then
        local decompressStart = GetTimePreciseSec()
        local decompressed = LibDeflate:DecompressDeflate(payload)
        local decompressTime = (GetTimePreciseSec() - decompressStart) * 1000

        local deserializeStart = GetTimePreciseSec()
        local ok, state = Addon:Deserialize(decompressed)
        local deserializeTime = (GetTimePreciseSec() - deserializeStart) * 1000

        if not ok then
            return
        end

        -- apply the trade state delta if it is ahead of ours
        local isHigherRevision = state.revTrades > self.db.revTrades
        if isHigherRevision then
            for id, trade in pairs(state.trades or {}) do
                local oldTrade = self.db.trades[id]
                self.db.trades[id] = trade

                if not oldTrade then
                    -- new trade
                    API:FireEvent(ns.T_TRADE_SYNCED, { trade = trade, source = "create" })
                elseif oldTrade.rev == trade.rev then
                    -- same revision, skip
                else
                    -- trade updated
                    API:FireEvent(ns.T_TRADE_SYNCED, { trade = trade })
                end
            end

            for _, id in ipairs(state.deletedTradeIds or {}) do
                self.db.trades[id] = nil
            end

            self.db.revTrades = state.revTrades
            self.db.lastTradeUpdateAt = state.lastTradeUpdateAt

            API:FireEvent(ns.T_ON_TRADE_STATE_UPDATE)

            -- optionally fire a "trade state updated" event
            ns.DebugLog(string.format("[DEBUG] Updated local trade state with %d new/updated trades, %d deleted trades, revTrades %d (compressed bytes: %d, decompress: %.0fms, deserialize: %.0fms)",
                    #(state.trades or {}), #(state.deletedTradeIds or {}),
                    self.db.revTrades,
                    #payload, decompressTime, deserializeTime
            ))
        else
            ns.DebugLog("[DEBUG] Outdated trade state ignored", state.revTrades, self.db.revTrades)
        end

        -- Broadcast trade ACK
        self:BroadcastAck(ns.T_TRADE_ACK, self.db.revTrades, isHigherRevision, "tradeAckBroadcasted")

    elseif dataType == ns.T_RATING_STATE_REQUEST then
        self:HandleStateUpdate(sender, ns.T_RATING_STATE_REQUEST, {
            rev = self.db.revRatings or 0,
            payloadRev = payload.revision,
            getLastAck = function(sender)
                return self.lastAckRatingRevisions[sender]
            end,
            setLastAck = function(sender, value)
                self.lastAckRatingRevisions[sender] = value
            end
        }, function()
            local responsePayload, ratingCount, deletedCount = self:BuildRatingsDeltaState(payload.revision, payload.ratings)
            local compressed = LibDeflate:CompressDeflate(Addon:Serialize(responsePayload))

            self:SendDm(Addon:Serialize({ ns.T_RATING_STATE, compressed }), sender, "BULK")
        end)

    elseif dataType == ns.T_RATING_STATE then
        local decompressed = LibDeflate:DecompressDeflate(payload)
        local ok, state = Addon:Deserialize(decompressed)
        if not ok then
            return
        end

        local isHigherRevision = state.revision > self.db.revRatings
        if isHigherRevision then
            -- Update local ratings with received data
            for id, rating in pairs(state.ratings or {}) do
                self.db.ratings[id] = rating
                API:FireEvent(ns.T_RATING_SYNCED, { rating = rating })
            end

            -- Delete ratings that are no longer valid
            for _, id in ipairs(state.deletedRatingIds or {}) do
                self.db.ratings[id] = nil
            end

            self.db.revRatings = state.revision
            self.db.lastRatingUpdateAt = state.lastUpdateAt
            API:FireEvent(ns.T_ON_RATING_STATE_UPDATE)
        end

        -- Broadcast rating ACK
        self:BroadcastAck(ns.T_RATING_ACK, self.db.revRatings, isHigherRevision, "ratingAckBroadcasted")

    elseif dataType == ns.T_LFG_STATE_REQUEST then
        self:HandleStateUpdate(sender, ns.T_LFG_STATE_REQUEST, {
            rev = self.db.revLfg or 0,
            payloadRev = payload.revLfg,
            getLastAck = function(sender)
                return self.lastAckLFGRevisions[sender]
            end,
            setLastAck = function(sender, value)
                self.lastAckLFGRevisions[sender] = value
            end
        }, function()
            local responsePayload, lfgCount, deletedCount = self:BuildLFGDeltaState(payload.revLfg, payload.lfgEntries)
            local compressed = LibDeflate:CompressDeflate(Addon:Serialize(responsePayload))

            self:SendDm(Addon:Serialize({ ns.T_LFG_STATE, compressed }), sender, "BULK")
        end)

    elseif dataType == ns.T_LFG_STATE then
        local decompressed = LibDeflate:DecompressDeflate(payload)
        local ok, state = Addon:Deserialize(decompressed)
        if not ok then
            return
        end

        local isHigherRevision = state.revLfg > self.db.revLfg
        if isHigherRevision then
            for user, entry in pairs(state.lfg or {}) do
                local oldEntry = self.db.lfg[user]
                self.db.lfg[user] = entry
                if not oldEntry then
                    API:FireEvent(ns.T_LFG_SYNCED, { lfg = entry, source = "create" })
                else
                    API:FireEvent(ns.T_LFG_SYNCED, { lfg = entry })
                end
            end
            for _, user in ipairs(state.deletedLFGIds or {}) do
                self.db.lfg[user] = nil
            end
            self.db.revLfg = state.revLfg
            self.db.lastLfgUpdateAt = state.lastUpdateAt
            API:FireEvent(ns.T_ON_LFG_STATE_UPDATE)
        end

        -- Broadcast LFG ACK
        self:BroadcastAck(ns.T_LFG_ACK, self.db.revLfg, isHigherRevision, "lfgAckBroadcasted")

    elseif dataType == ns.T_ADDON_VERSION_REQUEST then
        knownAddonVersions[payload.version] = true
        local latestVersion = ns.GetLatestVersion(knownAddonVersions)
        if latestVersion ~= payload.version then
            payload = { version = latestVersion }
            if ns.ChangeLog[latestVersion] then
                payload.changeLog = ns.ChangeLog[latestVersion]
            end
            self:SendDm(Addon:Serialize({ ns.T_ADDON_VERSION_RESPONSE, payload }), sender, "BULK")
        end
    elseif dataType == ns.T_ADDON_VERSION_RESPONSE then
        ns.DebugLog("[DEBUG] new addon version available", payload.version)
        knownAddonVersions[payload.version] = true
        if payload.changeLog then
            ns.ChangeLog[payload.version] = payload.changeLog
        end

    elseif dataType == ns.T_BLACKLIST_ADD_OR_UPDATE then
        -- "payload" looks like { playerName = "Alice", rev = 5, namesByType = { review = { "enemy1", "enemy2" } } }
        ns.BlacklistAPI:UpdateDBBlacklist(payload)
        API:FireEvent(ns.T_BLACKLIST_ADD_OR_UPDATE, payload)

        -- deletions are not supported, top-level entries just become empty if everything's been un-blacklisted
        -- elseif dataType == ns.T_BLACKLIST_DELETED then
        --     -- "payload" might be { playerName = "Alice" }
        --     if self.db.blacklists[payload.playerName] ~= nil then
        --         self.db.blacklists[payload.playerName] = nil
        --         if (self.db.revBlacklists or 0) < (payload.rev or 0) then
        --             self.db.revBlacklists = payload.rev
        --             self.db.lastBlacklistUpdateAt = time()
        --         end
        --         API:FireEvent(ns.T_BLACKLIST_DELETED, payload)
        --     end

    elseif dataType == ns.T_BLACKLIST_STATE_REQUEST then
        self:HandleStateUpdate(sender, ns.T_BLACKLIST_STATE_REQUEST, {
            rev = self.db.revBlacklists or 0,
            payloadRev = payload.revBlacklists,
            getLastAck = function(sender)
                return self.lastAckBlacklistRevisions[sender]
            end,
            setLastAck = function(sender, value)
                self.lastAckBlacklistRevisions[sender] = value
            end
        }, function()
            local responsePayload, blCount, deletedCount = self:BuildBlacklistDeltaState(payload.revBlacklists, payload.blacklistEntries)
            local compressed = LibDeflate:CompressDeflate(Addon:Serialize(responsePayload))

            self:SendDm(Addon:Serialize({ ns.T_BLACKLIST_STATE, compressed }), sender, "BULK")
        end)

    elseif dataType == ns.T_BLACKLIST_STATE then
        local decompressStart = GetTimePreciseSec()
        local decompressed = LibDeflate:DecompressDeflate(payload)
        local decompressTime = (GetTimePreciseSec() - decompressStart) * 1000

        local deserializeStart = GetTimePreciseSec()
        local ok, state = Addon:Deserialize(decompressed)
        local deserializeTime = (GetTimePreciseSec() - deserializeStart) * 1000

        if not ok then
            return
        end

        local isHigherRevision = state.revBlacklists > (self.db.revBlacklists or 0)
        if isHigherRevision then
            -- Update local blacklists
            for user, entry in pairs(state.blacklists or {}) do
                local oldEntry = self.db.blacklists[user]
                self.db.blacklists[user] = entry
                if not oldEntry then
                    API:FireEvent(ns.T_BLACKLIST_SYNCED, { blacklist = entry, source = "create" })
                else
                    API:FireEvent(ns.T_BLACKLIST_SYNCED, { blacklist = entry })
                end
            end
            -- Delete blacklists from local that are no longer in the received state
            for _, user in ipairs(state.deletedBlacklistIds or {}) do
                self.db.blacklists[user] = nil
            end

            -- Bump our local revision
            self.db.revBlacklists = state.revBlacklists
            self.db.lastBlacklistUpdateAt = state.lastBlacklistUpdateAt

            API:FireEvent(ns.T_ON_BLACKLIST_STATE_UPDATE)

            ns.DebugLog(string.format(
                    "[DEBUG] Updated local blacklists with %d new/updated, %d deleted, revBlacklists %d (compressed: %d, decompress: %.0fms, deserialize: %.0fms)",
                    #(state.blacklists or {}), #(state.deletedBlacklistIds or {}),
                    self.db.revBlacklists, #payload, decompressTime, deserializeTime
            ))
        else
            ns.DebugLog("[DEBUG] Outdated blacklist state ignored", state.revBlacklists, self.db.revBlacklists)
        end

        self:BroadcastAck(ns.T_BLACKLIST_ACK, self.db.revBlacklists, isHigherRevision, "blacklistAckBroadcasted")

    elseif dataType == ns.T_SET_GUILD_POINTS then
        ns.OffsetMyGuildPoints(payload.points, payload.txId)

    elseif dataType == ns.T_PENDING_TRANSACTION_STATE_REQUEST then
        self:HandleStateUpdate(sender, ns.T_PENDING_TRANSACTION_STATE_REQUEST, {
            rev = self.db.revPendingTransactions or 0,
            payloadRev = payload.revPendingTransactions,
            getLastAck = function(sender)
                return self.lastAckPendingTransactionRevisions[sender]
            end,
            setLastAck = function(sender, value)
                self.lastAckPendingTransactionRevisions[sender] = value
            end
        }, function()
            local responsePayload, txnCount, deletedCount = self:BuildPendingTransactionsDeltaState(payload.revPendingTransactions, payload.pendingTransactions)
            local compressed = LibDeflate:CompressDeflate(Addon:Serialize(responsePayload))

            self:SendDm(Addon:Serialize({ ns.T_PENDING_TRANSACTION_STATE, compressed }), sender, "BULK")
        end)

    elseif dataType == ns.T_PENDING_TRANSACTION_STATE then
        local decompressStart = GetTimePreciseSec()
        local decompressed = LibDeflate:DecompressDeflate(payload)
        local decompressTime = (GetTimePreciseSec() - decompressStart) * 1000

        local ok, state = Addon:Deserialize(decompressed)
        if not ok then
            return
        end

        local isHigherRevision = state.revPendingTransactions > (self.db.revPendingTransactions or 0)
        if isHigherRevision then
            for id, txn in pairs(state.pendingTransactions or {}) do
                local oldTxn = (self.db.pendingTransactions or {})[id]
                if not self.db.pendingTransactions then
                    self.db.pendingTransactions = {}
                end
                self.db.pendingTransactions[id] = txn
                if not oldTxn then
                    API:FireEvent(ns.T_PENDING_TRANSACTION_SYNCED, { pendingTransaction = txn, source = "create" })
                else
                    API:FireEvent(ns.T_PENDING_TRANSACTION_SYNCED, { pendingTransaction = txn })
                end

                -- Handle each transaction in the sync
                ns.PendingTxAPI:HandlePendingTransactionChange(txn)
            end

            for _, id in ipairs(state.deletedTxnIds or {}) do
                if self.db.pendingTransactions then
                    self.db.pendingTransactions[id] = nil
                end
            end

            self.db.revPendingTransactions = state.revPendingTransactions
            self.db.lastPendingTransactionUpdateAt = state.lastPendingTransactionUpdateAt

            API:FireEvent(ns.T_ON_PENDING_TRANSACTION_STATE_UPDATE)

            ns.DebugLog(string.format("[DEBUG] Updated local pending transactions with %d new/updated, %d deleted, revPendingTransactions %d (compressed: %d, decompress: %.0fms)",
                    #(state.pendingTransactions or {}), #(state.deletedTxnIds or {}), self.db.revPendingTransactions, #payload, decompressTime))
        else
            ns.DebugLog("[DEBUG] Outdated pending transactions state ignored", state.revPendingTransactions, self.db.revPendingTransactions)
        end

        -- Broadcast pending transaction ACK
        self:BroadcastAck(ns.T_PENDING_TRANSACTION_ACK, self.db.revPendingTransactions, isHigherRevision, "pendingTransactionAckBroadcasted")

    elseif dataType == ns.T_AUCTION_ACK then
        self:HandleAck("auction", sender, payload, self.lastAckAuctionRevisions)
    elseif dataType == ns.T_TRADE_ACK then
        self:HandleAck("trade", sender, payload, self.lastAckTradeRevisions)
    elseif dataType == ns.T_RATING_ACK then
        self:HandleAck("rating", sender, payload, self.lastAckRatingRevisions)
    elseif dataType == ns.T_LFG_ACK then
        self:HandleAck("LFG", sender, payload, self.lastAckLFGRevisions)
    elseif dataType == ns.T_BLACKLIST_ACK then
        self:HandleAck("blacklist", sender, payload, self.lastAckBlacklistRevisions)
    elseif dataType == ns.T_PENDING_TRANSACTION_ACK then
        self:HandleAck("pending transaction", sender, payload, self.lastAckPendingTransactionRevisions)

    else
        ns.DebugLog("[DEBUG] unknown event type", dataType)
    end
end

function AuctionHouse:BuildDeltaState(requesterRevision, requesterAuctions)
    local auctionsToSend = {}
    local deletedAuctionIds = {}
    local auctionCount = 0
    local deletionCount = 0

    if not requesterRevision or requesterRevision < self.db.revision then
        -- Convert requesterAuctions array to lookup table with revisions
        local requesterAuctionLookup = {}
        for _, auctionInfo in ipairs(requesterAuctions or {}) do
            requesterAuctionLookup[auctionInfo.id] = auctionInfo.rev
        end

        -- Find auctions to send (those that requester doesn't have or has older revision)
        for id, auction in pairs(ns.FilterAuctionsThisRealm(self.db.auctions)) do
            local requesterRev = requesterAuctionLookup[id]
            if not requesterRev or (auction.rev > requesterRev) then
                auctionsToSend[id] = auction
                auctionCount = auctionCount + 1
            end
        end

        -- Find deleted auctions (present in requester but not in current state)
        for id, _ in pairs(requesterAuctionLookup) do
            if not self.db.auctions[id] then
                table.insert(deletedAuctionIds, id)
                deletionCount = deletionCount + 1
            end
        end
    end

    -- Construct the response payload
    return {
        v = 1,
        auctions = auctionsToSend,
        deletedAuctionIds = deletedAuctionIds,
        revision = self.db.revision,
        lastUpdateAt = self.db.lastUpdateAt,
    }, auctionCount, deletionCount
end

function AuctionHouse:BuildTradeDeltaState(requesterRevision, requesterTrades)
    local tradesToSend = {}
    local deletedTradeIds = {}
    local tradeCount = 0
    local deletionCount = 0

    -- If requester is behind, then we figure out what trades changed or were deleted
    if not requesterRevision or requesterRevision < self.db.revTrades then
        -- Build a lookup table of the requester's trades, keyed by trade id → revision
        local requesterTradeLookup = {}
        for _, tradeInfo in ipairs(requesterTrades or {}) do
            requesterTradeLookup[tradeInfo.id] = tradeInfo.rev
        end

        -- Collect trades that need to be sent because the requester doesn't have them
        for id, trade in pairs(self.db.trades) do
            local requesterRev = requesterTradeLookup[id]
            if not requesterRev or (trade.rev > requesterRev) then
                tradesToSend[id] = trade
                tradeCount = tradeCount + 1
            end
        end

        -- Detect trades the requester has, but we don't (deleted or no longer valid)
        for id, _ in pairs(requesterTradeLookup) do
            if not self.db.trades[id] then
                table.insert(deletedTradeIds, id)
                deletionCount = deletionCount + 1
            end
        end
    end

    return {
        v = 1,
        trades = tradesToSend,
        deletedTradeIds = deletedTradeIds,
        revTrades = self.db.revTrades or 0,
        lastTradeUpdateAt = self.db.lastTradeUpdateAt,
    }, tradeCount, deletionCount
end

function AuctionHouse:BuildRatingsDeltaState(requesterRevision, requesterRatings)
    local ratingsToSend = {}
    local deletedRatingIds = {}
    local ratingCount = 0
    local deletionCount = 0

    if not requesterRevision or requesterRevision < self.db.revRatings then
        -- Convert requesterRatings array to lookup table with revisions
        local requesterRatingLookup = {}
        for _, ratingInfo in ipairs(requesterRatings or {}) do
            requesterRatingLookup[ratingInfo.id] = ratingInfo.rev
        end

        -- Find ratings to send (those that requester doesn't have or has older revision)
        for id, rating in pairs(self.db.ratings) do
            local requesterRev = requesterRatingLookup[id]
            if not requesterRev or (rating.rev > requesterRev) then
                ratingsToSend[id] = rating
                ratingCount = ratingCount + 1
            end
        end

        -- Find deleted ratings (present in requester but not in current state)
        for id, _ in pairs(requesterRatingLookup) do
            if not self.db.ratings[id] then
                table.insert(deletedRatingIds, id)
                deletionCount = deletionCount + 1
            end
        end
    end

    -- Construct the response payload
    return {
        v = 1,
        ratings = ratingsToSend,
        deletedRatingIds = deletedRatingIds,
        revision = self.db.revRatings,
        lastUpdateAt = self.db.lastRatingUpdateAt,
    }, ratingCount, deletionCount
end

-- Newly added BuildLFGDeltaState function to handle LFG syncing
function AuctionHouse:BuildLFGDeltaState(requesterRevision, requesterLFG)
    local lfgToSend = {}
    local deletedLFGIds = {}
    local lfgCount = 0
    local deletionCount = 0

    if not requesterRevision or requesterRevision < (self.db.revLfg or 0) then
        local requesterLFGLookup = {}
        for _, info in ipairs(requesterLFG or {}) do
            requesterLFGLookup[info.name] = info.rev
        end

        for user, entry in pairs(self.db.lfg or {}) do
            local rRev = requesterLFGLookup[user]
            if not rRev or (entry.rev > rRev) then
                lfgToSend[user] = entry
                lfgCount = lfgCount + 1
            end
        end
        for user, _ in pairs(requesterLFGLookup) do
            if not self.db.lfg[user] then
                table.insert(deletedLFGIds, user)
                deletionCount = deletionCount + 1
            end
        end
    end

    return {
        v = 1,
        lfg = lfgToSend,
        deletedLFGIds = deletedLFGIds,
        revLfg = self.db.revLfg or 0,
        lastUpdateAt = self.db.lastLfgUpdateAt or 0,
    }, lfgCount, deletionCount
end

function AuctionHouse:BuildBlacklistDeltaState(requesterRevision, requesterBlacklists)
    -- We'll return a table of updated items plus a list of deleted ones.
    local blacklistsToSend = {}
    local deletedBlacklistIds = {}
    local blacklistCount = 0
    local deletionCount = 0

    if not requesterRevision or requesterRevision < (self.db.revBlacklists or 0) then
        -- Convert the requester's blacklist array into a name->rev lookup with blType
        local requesterBLLookup = {}
        for _, info in ipairs(requesterBlacklists or {}) do
            requesterBLLookup[info.playerName] = info.rev
        end

        -- For each local playerName in blacklists
        for playerName, blacklist in pairs(self.db.blacklists or {}) do
            local requesterRev = requesterBLLookup[playerName]
            if not requesterRev or (blacklist.rev > requesterRev) then
                blacklistsToSend[playerName] = blacklist
                blacklistCount = blacklistCount + 1
            end
        end

        -- Detect blacklists the requester has, but we don't (deleted)
        for playerName, _ in pairs(requesterBLLookup) do
            if not self.db.blacklists[playerName] then
                table.insert(deletedBlacklistIds, playerName)
                deletionCount = deletionCount + 1
            end
        end
    end

    return {
        v = 1,
        blacklists = blacklistsToSend,
        deletedBlacklistIds = deletedBlacklistIds,
        revBlacklists = self.db.revBlacklists or 0,
        lastBlacklistUpdateAt = self.db.lastBlacklistUpdateAt or 0,
    }, blacklistCount, deletionCount
end

function AuctionHouse:BuildPendingTransactionsDeltaState(requesterRevision, requesterTxns)
    local txnsToSend = {}
    local deletedTxnIds = {}
    local txnCount = 0
    local deletionCount = 0

    if not requesterRevision or requesterRevision < (self.db.revPendingTransactions or 0) then
        local requesterTxnLookup = {}
        for _, info in ipairs(requesterTxns or {}) do
            requesterTxnLookup[info.id] = info.rev
        end

        for id, txn in pairs(self.db.pendingTransactions or {}) do
            local requesterRev = requesterTxnLookup[id]
            if not requesterRev or (txn.rev > requesterRev) then
                txnsToSend[id] = txn
                txnCount = txnCount + 1
            end
        end

        for id, _ in pairs(requesterTxnLookup) do
            if not self.db.pendingTransactions or not self.db.pendingTransactions[id] then
                table.insert(deletedTxnIds, id)
                deletionCount = deletionCount + 1
            end
        end
    end

    return {
        v = 1,
        pendingTransactions = txnsToSend,
        deletedTxnIds = deletedTxnIds,
        revPendingTransactions = self.db.revPendingTransactions or 0,
        lastPendingTransactionUpdateAt = self.db.lastPendingTransactionUpdateAt or 0,
    }, txnCount, deletionCount
end

function AuctionHouse:RequestLatestConfig()
    self:BroadcastMessage(Addon:Serialize({ T_CONFIG_REQUEST, { version = AHConfigSaved.version } }))
end

function AuctionHouse:RequestOffsetGuildPoints(playerName, points, txId)
    self:SendDm(Addon:Serialize({ ns.T_SET_GUILD_POINTS, { points = points, txId = txId } }), playerName, "NORMAL")
end

function AuctionHouse:BuildAuctionsTable()
    local auctions = {}
    for id, auction in pairs(ns.FilterAuctionsThisRealm(self.db.auctions)) do
        table.insert(auctions, { id = id, rev = auction.rev })
    end
    return auctions
end

function AuctionHouse:BuildTradesTable()
    local trades = {}
    for id, trade in pairs(self.db.trades) do
        table.insert(trades, { id = id, rev = trade.rev })
    end
    return trades
end

function AuctionHouse:BuildRatingsTable()
    local ratings = {}
    for id, rating in pairs(self.db.ratings) do
        table.insert(ratings, { id = id, rev = rating.rev })
    end
    return ratings
end

function AuctionHouse:BuildDeathClipsTable(now)
    local allClips = ns.GetLiveDeathClips()
    local fromTs = now - ns.GetConfig().deathClipsSyncWindow
    local clips = {}
    for clipID, clip in pairs(allClips) do
        if clip.ts and clip.ts >= fromTs then
            clips[clipID] = true
        end
    end

    local payload = { fromTs = fromTs, clips = clips }
    return payload
end

-- Build a table of LFG entries for a request
function AuctionHouse:BuildLFGTable()
    local lfgEntries = {}
    for user, entry in pairs(self.db.lfg or {}) do
        table.insert(lfgEntries, { name = user, rev = entry.rev })
    end
    return lfgEntries
end

function AuctionHouse:BuildBlacklistTable()
    local blacklistEntries = {}
    for playerName, blacklist in pairs(self.db.blacklists or {}) do
        table.insert(blacklistEntries, { playerName = playerName, rev = blacklist.rev })
    end
    return blacklistEntries
end

function AuctionHouse:BuildPendingTransactionsTable()
    local pendingTxns = {}
    for id, txn in pairs(self.db.pendingTransactions or {}) do
        table.insert(pendingTxns, { id = id, rev = txn.rev })
    end
    return pendingTxns
end

function AuctionHouse:RequestLatestState()
    -- Reset ACK flags for a new request cycle.
    self.ackBroadcasted = false
    self.lastAckAuctionRevisions = {} -- Clear all ACKs when starting a new request

    local auctions = self:BuildAuctionsTable()
    local payload = { T_AUCTION_STATE_REQUEST, { revision = self.db.revision, auctions = auctions } }
    local msg = Addon:Serialize(payload)

    self:BroadcastMessage(msg)
end

function AuctionHouse:RequestLatestTradeState()
    local trades = self:BuildTradesTable()
    local payload = { ns.T_TRADE_STATE_REQUEST, { revTrades = self.db.revTrades, trades = trades } }
    local msg = Addon:Serialize(payload)

    self:BroadcastMessage(msg)
end

function AuctionHouse:RequestLatestRatingsState()
    local ratings = self:BuildRatingsTable()
    local payload = { ns.T_RATING_STATE_REQUEST, { revision = self.db.revRatings, ratings = ratings } }
    local msg = Addon:Serialize(payload)

    self:BroadcastMessage(msg)
end

function AuctionHouse:RequestLatestDeathClipState(now)
    -- ── DEBUG TICKET ──
    -- assign a unique ID and enqueue this run's start time
    self.benchDebugCounter = (self.benchDebugCounter or 0) + 1
    local dbgID            = self.benchDebugCounter
    local dbgStart         = GetTime()
    self.benchDebugQueue   = self.benchDebugQueue or {}
    table.insert(self.benchDebugQueue, { id = dbgID, start = dbgStart })

    -- unchanged print
    print(("|cff00ff00>> Bench[%d]: DeathClip sync requested at %s|r")
            :format(dbgID, date("%H:%M")))

    local clips   = self:BuildDeathClipsTable(now)
    local payload = {
        ns.T_DEATH_CLIPS_STATE_REQUEST,
        { since = ns.GetLastDeathClipTimestamp(), clips = clips }
    }

    -- 1. Serialize
    local serialized = Addon:Serialize(payload)
    -- 2. Compress (raw bytes)
    local compressionConfigs = {level = 9}
    local compressed = LibDeflate:CompressDeflate(serialized, compressionConfigs)
    -- 3. Encode (ASCII-safe)
    local encoded    = LibDeflate:EncodeForWoWAddonChannel(compressed)
    -- 4. Prepend our marker
    local msg        = "DF:" .. encoded

    -- 5. Send it off
    self:BroadcastMessage(msg)
end

function AuctionHouse:RequestLatestLFGState()
    local lfgEntries = self:BuildLFGTable()
    local payload = { ns.T_LFG_STATE_REQUEST, { revLfg = self.db.revLfg or 0, lfgEntries = lfgEntries } }
    local msg = Addon:Serialize(payload)
    self:BroadcastMessage(msg)
end

function AuctionHouse:RequestLatestBlacklistState()
    local blacklistEntries = self:BuildBlacklistTable()
    local payload = {
        ns.T_BLACKLIST_STATE_REQUEST,
        { revBlacklists = self.db.revBlacklists or 0, blacklistEntries = blacklistEntries }
    }
    local msg = Addon:Serialize(payload)
    self:BroadcastMessage(msg)
end

function AuctionHouse:RequestDeathClipReviewState()
    local payload = { ns.T_DEATH_CLIP_REVIEW_STATE_REQUEST, { rev = ns.GetDeathClipReviewState().persisted.rev } }
    local msg = Addon:Serialize(payload)
    self:BroadcastMessage(msg)
end

function AuctionHouse:RequestLatestPendingTransactionState()
    local pendingTransactions = self:BuildPendingTransactionsTable()
    local payload = { ns.T_PENDING_TRANSACTION_STATE_REQUEST, { revPendingTransactions = self.db.revPendingTransactions or 0, pendingTransactions = pendingTransactions } }
    local msg = Addon:Serialize(payload)
    self:BroadcastMessage(msg)
end

SLASH_atheneclear1 = "/atheneclear"
SlashCmdList["atheneclear"] = function(msg)
    AtheneClearPersistence()
end

function AtheneClearPersistence()
    ns.AuctionHouseAPI:ClearPersistence()
    print("Persistence cleared")
end

function AuctionHouse:RequestAddonVersion()
    local payload = { ns.T_ADDON_VERSION_REQUEST, { version = self.addonVersion } }
    local msg = Addon:Serialize(payload)
    self:BroadcastMessage(msg)
end
function AuctionHouse:GetLatestVersion()
    return ns.GetLatestVersion(knownAddonVersions)
end

function AuctionHouse:IsUpdateAvailable()
    local latestVersion = ns.GetLatestVersion(knownAddonVersions)
    return ns.CompareVersions(latestVersion, self.addonVersion) > 0
end

function AuctionHouse:IsImportantUpdateAvailable()
    local latestVersion = ns.GetLatestVersion(knownAddonVersions)
    return ns.CompareVersionsExclPatch(latestVersion, self.addonVersion) > 0
end

function AuctionHouse:OpenAuctionHouse()
    ns.TryExcept(
            function()
                if self:IsImportantUpdateAvailable() and not ns.ShowedUpdateAvailablePopupRecently() then
                    ns.ShowUpdateAvailablePopup()
                else
                    OFAuctionFrame:Show()
                end
            end,
            function(err)
                ns.DebugLog("[ERROR] Failed to open auction house", err)
                OFAuctionFrame:Show()
            end
    )
end

ns.GameEventHandler:On("PLAYER_REGEN_DISABLED", function()
    -- player entered combat, close the auction house to be safe
    if OFAuctionFrame:IsShown() then
        OFAuctionFrame:Hide()
    else
        OFCloseAuctionStaticPopups()
    end
    StaticPopup_Hide("OF_LEAVE_REVIEW")
    StaticPopup_Hide("OF_UPDATE_AVAILABLE")
    StaticPopup_Hide("OF_BLACKLIST_PLAYER_DIALOG")
    StaticPopup_Hide("OF_DECLINE_ALL")
    StaticPopup_Hide("GAH_MAIL_CANCEL_AUCTION")
end)

-- Function to clean up auctions and trades
function AuctionHouse:CleanupAuctionsAndTrades()
    local me = UnitName("player")

    -- cleanup auctions
    local auctions = API:QueryAuctions(function(auction)
        return auction.owner == me or auction.buyer == me
    end)
    for _, auction in ipairs(auctions) do
        if auction.status == ns.AUCTION_STATUS_SENT_LOAN then
            if auction.owner == me then
                API:MarkLoanComplete(auction.id)
            else
                API:DeclareBankruptcy(auction.id)
            end
        else
            API:DeleteAuctionInternal(auction.id)
        end
    end

    local trades = API:GetMyTrades()
    for _, trade in ipairs(trades) do
        if trade.auction.buyer == me then
            API:SetBuyerDead(trade.id)
        end
        if trade.auction.owner == me then
            API:SetSellerDead(trade.id)
        end
    end
end

local function playRandomDeathClip()
    if GetRealmName() ~= "Doomhowl" then
        return
    end

    local clipNum = random(1, 24)
    PlaySoundFile("Interface\\AddOns\\" .. addonName .. "\\Media\\DeathAudioClips\\death_" .. clipNum .. ".mp3", "Master")
end

ns.GameEventHandler:On("PLAYER_DEAD", function()
    print(ChatPrefix() .. " " .. L["removing auctions after death"])
    AuctionHouse:CleanupAuctionsAndTrades()
    playRandomDeathClip()
end)

local function cleanupIfKicked()
    if not IsInGuild() then
        print(ChatPrefix() .. " " .. L["removing auctions after gkick"])
        AuctionHouse:CleanupAuctionsAndTrades()
    end
end

ns.GameEventHandler:On("PLAYER_GUILD_UPDATE", function()
    -- Check guild status after some time, to make sure IsInGuild is accurate
    C_Timer:After(3, cleanupIfKicked)
end)
ns.GameEventHandler:On("PLAYER_ENTERING_WORLD", function()
    C_Timer:After(10, cleanupIfKicked)
end)

ns.AuctionHouseClass = AuctionHouse
ns.AuctionHouse = AuctionHouse.new(UnitName("player"))

function Addon:OnInitialize()
    ns.AuctionHouse:Initialize()
end